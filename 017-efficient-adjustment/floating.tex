\documentclass{llncs}
% generated by Madoko, version 1.2.3
%mdk-data-line={1}


\usepackage[heading-base={2},section-num={False},bib-label={hide},fontspec={True}]{madoko2}
\usepackage{fleqn}
\usepackage{tikz-cd}
%mdk-data-line={34;koka-style.mdk:201}

    \newlength\mdxwidth
    \newcommand\ifnowidth[3]{% 
       \settowidth{\mdxwidth}{#1}%
       \ifdim\mdxwidth>0pt\relax#3\else#2\fi
    }
    \newcommand{\rulename}[1]{\ensuremath{#1}}
    \newcommand{\brulename}[1]{\ifnowidth{\ensuremath{#1}}{}{\;\scriptsize{[\textsc{#1}]}}}    
    \newcommand{\infer}[3]{\dfrac{\begin{array}{llll}#1\end{array}}{\begin{array}{llll}#2\end{array}}{\;#3}}
    \newcommand{\lam}[3]{\lambda^{#1} #2.\,#3}
    \newcommand{\Lam}[2]{\Lambda #1.\,#2}
    \newcommand{\comp}[1]{\overline{#1}}
    \newcommand{\bind}[4]{\mathsf{bind}_{#1}(#2,#3,#4)}
    \newcommand{\apply}[2]{\mathsf{apply}_{#1}(#2)}
    \newcommand{\rlam}[1]{\lambda\kern -0.95ex\lambda_{#1}}
    \newcommand\llangle{\langle\kern -0.45ex\langle\kern 0.15ex}
    \newcommand\rrangle{\kern 0.15ex\rangle\kern -0.55ex\rangle}
    \newcommand\dash{\hspace{-0.45ex}\mbox{-}\hspace{-0.5ex}}
    \newcommand\xlongmapsto{\longmapsto^*}%\hspace{-2.8ex}\rightarrow\;}
    \renewcommand\mathspace{\mskip 3mu plus 0.5mu minus 0.5mu\smallstrut}
    \newcommand\disjoint{\not\strut\hspace{-1.1ex}\cap\;}% 
    \newcommand\cnot[1]{\mathrel{\ooalign{\hfil$#1$\hfil\cr\hfil$/$\hfil\cr}}}
    \newcommand\itcorrect[1]{#1\hspace{0.15ex}}
    %\appto\langle{\mkern-2mu}
    %\preto\rangle{\mkern-1mu}
    \newcommand\total{\langle\mkern 3mu\rangle}
    \newcommand\bigline{\rule[-1.4ex]{0pt}{4ex}}
    \newcommand\reduce[1]{\overline{#1}}
    \newcommand\wreduce[1]{\reduce{#1}}
    \renewcommand\notin{\!\not\strut\!\!\!\in}
    \newcommand\llambda{\lambda\hspace{-1ex}\lambda}
    \newcommand\calls[1]{|#1|}
    \DeclareSymbolFont{modernmath}{OML}{ptm}{m}{n}
    \DeclareMathSymbol{\mlambda}{\mathord}{modernmath}{"15}
    \newcommand{\evec}[1]{\llangle #1\rrangle}
    \newcommand{\kwevv}{\mathkw{evv}}
    \newcommand{\tup}[2]{\llparenthesis#1,#2\rrparenthesis}
    \newcommand{\vvdash}[1]{\!\Vdash_{\!\textsf{#1}}}
    \newcommand{\ins}[3]{\evec{#1\xcolon #2 \midbar #3}}
    \newcommand{\midbar}{\mid}
    \newcommand{\mbag}[1]{\{\!\!\{ {#1} \}\!\!\}}
    \DeclareMathSymbol{:}{\mathord}{operators}{"3A}
    \newcommand{\xcolon}{\,:\,}
    \makeatletter
    \newcommand*\bigcdot{\mathpalette\bigcdot@{.85}}
    \newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}    
    \makeatother
%mdk-data-line={33;style/llncs.mdk:7}

    %\pagestyle{plain}
%mdk-data-line={34;koka-style.mdk:249}

    %\renewcommand\mathit[1]{\textit{\fontfamily{lmr}\selectfont #1}}
    \newlength\mdpreopwidth
    \renewcommand{\ppreop}[1]{%
      \settowidth{\mdpreopwidth}{#1}%
      \ifdim\mdpreopwidth=0pt\relax\else\,{#1}\,\fi
    }
    \setlength\mdcompactskip{0.5ex}
    \renewcommand\prebr{\vspace{-0.3ex}\strut\newline\strut\ignorespaces}
    
    
\begin{document}

%mdk-data-line={35;paper-style.mdk:138}

    \setlength\mdpreskip{\abovedisplayskip}
    %\setlength\textfloatsep{0.75\textfloatsep}
    \abovedisplayskip=0pt
    \belowdisplayskip=\abovedisplayskip
    \abovedisplayshortskip=0pt
    \belowdisplayshortskip=\abovedisplayshortskip
    \parskip=0pt
    \setlength\mathindent{1em}
%mdk-data-line={80}

    %\addtolength{\textheight}{5pt}
    %\linespread{0.98}
    \setlength\textfloatsep{0.25\textfloatsep}
    %\setlength{\textfloatsep}{5pt plus 1.0pt minus 2.0pt}
    \renewcommand{\floatpagefraction}{.8}%
    \setlength\mdpreskip{\abovedisplayskip}
    \makeatletter
    \renewcommand\section{\@startsection{section}{1}{\z@}%
                       {-8\p@ \@plus -2\p@ \@minus -2\p@}%
                       {6\p@ \@plus 1\p@ \@minus 1\p@}%
                       {\normalfont\large\bfseries\boldmath
                        \rightskip=\z@ \@plus 8em\pretolerance=10000 }}
    \renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
                          {-8\p@ \@plus -2\p@ \@minus -2\p@}%
                          {4\p@ \@plus 1\p@ \@minus 1\p@}%
                          {\normalfont\normalsize\bfseries\boldmath
                            \rightskip=\z@ \@plus 8em\pretolerance=10000 }}
    \renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
                          {-8\p@ \@plus -2\p@ \@minus -2\p@}%
                          {-0.5em \@plus -0.22em \@minus -0.1em}%
                          {\normalfont\normalsize\bfseries\boldmath}}
    \renewcommand\paragraph{\@startsection{paragraph}{2}{\z@}%
                          {-6\p@ \@plus -2\p@ \@minus -2\p@}%
                          {-0.5em \@plus -0.22em \@minus -0.1em}%
                          {\normalfont\normalsize\itshape}}
    \makeatother

\setlength{\fboxsep}{0.1ex}
%\definecolor{light-gray}{gray}{0.85}
\newcommand{\gray}[1]{\colorbox{gainsboro}{$#1$}}
\definecolor{sidecolor}{HTML}{788ca2}
\newcommand{\fullwidth}[1]{\cspan{#1}{\hspace*{\dimexpr\linewidth - 1ex\relax}\vrule height0\baselineskip depth 0\baselineskip width 0\baselineskip}}
\newcommand{\side}[1]{{\color{sidecolor}{#1}}}

\newcommand\tr[1]{\lceil#1\rceil}
\newcommand{\trl}[1]{\tr{#1}^{l}}
\newcommand{\trm}[1]{\tr{#1}^{m}}
\newcommand\tru[1]{\lfloor#1\rfloor}
\newcommand\trmon[1]{\lfloor{#1}\rfloor}
\newcommand\trx[1]{\lceil\!\!\lceil#1\rceil\!\!\rceil}

\newcommand\ctx[1]{\lceil#1\rceil}
\newcommand\ev[1]{\overline{#1}}
\newcommand\evdecl[1]{\underline{#1}}
\newcommand\evt[1]{\llbracket #1 \rrbracket}%

\newcommand\under[2]{\underset{\raisebox{2mm}{$\scriptstyle #2$}}{#1}}
%\newcommand\inhx[2]{\under{#1}{\uparrow   \makebox[0pt]{\raisebox{-0.6ex}{$\scriptstyle\kern 1.3ex #2$}}}}
\newcommand\inhx[2]{\under{#1}{\under{\uparrow}{#2}}}
%\newcommand\synx[2]{\under{#1}{\downarrow \makebox[0pt]{\raisebox{-0.6ex}{$\scriptstyle\kern 2ex #2$}}}}
\newcommand\synx[2]{\under{#1}{\under{\downarrow}{#2}}}
\newcommand\inh[1]{\under{#1}{\uparrow}}
\newcommand\syn[1]{\under{#1}{\downarrow}}
\newcommand\append[2]{\evec{#1\midbar #2}} %{#1}{+}\!\!{+}{#2}}
\newcommand\appendop{\mathbin{{+}\!\!{+}}}
\newcommand{\restrict}[1]{\upharpoonright{#1}}

\newcommand\eraset[1]{#1^{*}} % how to erase types?
\newcommand\erasetp[1]{(#1)^{*}}
\newcommand\res{\mathid{restricted}}

\newcommand{\hole}{{\scriptstyle\square}}

\newcommand{\cspan}[2]{\multicolumn{#1}{l}{#2}}

\newcommand{\downstrut}{\vrule height 0ex depth 1.5ex width 0pt\relax}

\newcommand{\Fpwo}{F_{pwo}}
\newcommand{\lpw}{\lambda_{pw}}
\newcommand{\prefix}{\leqslant} % {\scriptstyle\sqsubseteq}\,}

\mdxtitleblockstart{}
\mdxtitle{Towards Efficient Adjustment of Effect Rows}%mdk
\mdxauthorstart{}
\mdxauthorname{Naoya Furudono}%mdk

\mdxauthoraddress{Tokyo Institute of Technology, Tokyo, Japan}%mdk

\mdxauthoremail{naoyafurudono@prg.is.titech.ac.jp}%mdk
\mdxauthorend\mdxauthorstart{}
\mdxauthorname{Youyou Cong}%mdk

\mdxauthoraddress{Tokyo Institute of Technology, Tokyo, Japan}%mdk

\mdxauthoremail{cong@c.titech.ac.jp}%mdk
\mdxauthorend\mdxauthorstart{}
\mdxauthorname{Hidehiko Masuhara}%mdk

\mdxauthoraddress{Tokyo Institute of Technology, Tokyo, Japan}%mdk

\mdxauthoremail{masuhara@acm.org}%mdk
\mdxauthorend\mdxauthorstart{}
\mdxauthorname{Daan Leijen}%mdk

\mdxauthoraddress{Microsoft Research, Seattle, USA}%mdk

\mdxauthoremail{daan@microsoft.com}%mdk
\mdxauthorend\mdtitleauthorrunning{}{N. Furudono et al.}\mdxtitleblockend%mdk

\begin{abstract}%mdk

\noindent Koka is a functional programming language with native support for algebraic effects and handlers.
To implement effect handler operations efficiently, Koka employs a semantics where the handlers
in scope are passed down to each function as an evidence vector.
At runtime, these evidence vectors are adjusted using the open constructs to match the evidence
for
 a particular function. All these adjustments can cause significant runtime overhead.
In this paper, we present a novel transformation on the Koka core calculus
that we call \emph{open floating}. This transformation aims to float up open constructs and combine
them in order to minimize the adjustments needed at runtime.
Open floating improves performance by 2.5\ensuremath{\times} in an experiment.
Furthermore, we formalize an aspect of row-based effect typing,
including the \emph{closed prefix} relation on effect rows, which
clarifies the constraint on open floating.%mdk
%mdk-begin-texraw
\keywords{Algebraic effect and handlers \and Type and effect system \and Compiler optimization}
%mdk
\end{abstract}%mdk



\section{1.\hspace*{0.5em}Introduction}\mdlabel{sec-intro}{1}%mdk%mdk

\noindent Algebraic effect handlers~[\mdcite{plotkin:handlers}{14}] are language feature for user-defined effects.
For instance, using effect handlers, we can support exception, asynchronous programming[\mdcite{leijen:async}{8}],
nondeterminism, and so on not as builtin features but as libraries.
While effect handlers are convenient, they incur more runtime overhead compared to native effects.
In order to fill in the gap of the performance, suitable semantics have been explored~[\mdcite{dolan2015effective}{2}, \mdcite{pretnar:efficientcomp}{15}, \mdcite{xie2020effect}{19}, \mdcite{xie:gep}{20}].%mdk

In this study, we focus on the evidence passing semantics~[\mdcite{xie:gep}{20}],
which is employed by the Koka language~[\mdcite{leijen:koka}{7}, \mdcite{leijen2017type}{9}, \mdcite{xie:gep}{20}].
The key idea of the semantics is to pass around a vector of handler implementations,
called an \emph{evidence vector}, and propagate it to algebraic effect operation calls,
exposing optimization opportunities. The row-based type-and-effect system ensures the correctness of
the dynamic semantics, where the static effect row type corresponds directly to the shape of the dynamic
evidence vector at runtime.%mdk

The Koka compiler automatically inserts $\mathpre{\mathkw{open}}$
constructs during type inference to adjust evidence vectors at runtime.
Unfortunately, each adjustment incurs runtime cost and,
being type-directed, the automatic insertion tends to generate many redundant $\mathpre{\mathkw{open}}$ calls around function applications.%mdk

In this paper, we present the \emph{open floating} algorithm to remove such $\mathpre{\mathkw{open}}$s as a compile-time optimization.
The algorithm first removes existing $\mathpre{\mathkw{open}}$s in a top-down way and
then re-assigns effect adjustment constructs back in a bottom-up way.
Unlike type inference phase insertion, the re-assignment is driven by the now explicit effect types,
ensuring preservation of the meaning of programs.
To give the reader a rough idea of the algorithm, we present programs before and after open floating.%mdk
\begin{mdtabular}{3}{\dimeval{(\linewidth-\dimwidth{0.48}-\dimwidth{0.10})/1}}{0pt}%mdk
\begin{tabular}{lll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.48}}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{k}~3~\}~\lambda\_.\\
\mdmathindent{2}\mathkw{let}~\mathid{x}~=~\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv}(3,2)~\mathkw{in}\\
\mdmathindent{2}\mathkw{let}~\mathid{y}~=~\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv}(3,\mathid{x})~\mathkw{in}\\
\mdmathindent{2}\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv}(3,~\mathid{y})\\
\mdmathindent{1}\quad
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.10}}%mdk
\noindent$\mathpre{\quad{\;\rightsquigarrow}\;\quad}$%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{k}~3~\}~\lambda\_.\\
\mdmathindent{2}\mathkw{restrict}~\total{}~(\\
\mdmathindent{4}\mathkw{let}~\mathid{x}~=~\mathid{safediv}(3,2)~\mathkw{in}\\
\mdmathindent{4}\mathkw{let}~\mathid{y}~=~\mathid{safediv}(3,\mathid{x})~\mathkw{in}\\
\mdmathindent{4}\mathid{safediv}(3,~\mathid{y}))
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\noindent Right one is faster than left one, due to the number of adjustments operations $\mathpre{\mathkw{open}}$ and $\mathpre{\mathkw{restrict}}$.
Both $\mathpre{\mathkw{open}}$ and $\mathpre{\mathkw{restrict}}$ perform the same adjustment thus the transformation decreases the number of adjustments.
The restrict construct can be applied to general expressions, not just functions.
This is essential to share a single
adjustment over multiple function applications.%mdk

In Section~\mdref{sec-overview}{2}, we give an overview of our study, and in the subsequent sections, we discuss the following contributions.%mdk

\begin{itemize}%mdk

\item{}
We define System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$, a system of effect handlers with the open construct.
The system is a core calculus of the Koka language, and is an extension of System $\mathpre{\mathsf{F}_{\mathid{pw}}}$ by~Xie and Leijen~[\mdcite{xie:gep}{20}].
We elaborate on effect typing in the extended system, showing%mdk

\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

\item how the type system checks the use of effect handlers (Section~\mdref{sec-static}{3.3})%mdk

\item an advantage of using rows for effect types rather than sets, which are popular in effect handler calculi~[\mdcite{brachthauser2020effekt}{1}, \mdcite{schrijvers:effsub}{16}] (Section~\mdref{sec-prefix}{3.4})%mdk

\item an effect type restriction on $\mathpre{\mathkw{open}}$ and $\mathpre{\mathkw{restrict}}$, which we call the \emph{closed prefix} relation (Section~\mdref{sec-prefix}{3.4}).%mdk
%mdk
\end{itemize}%mdk

In particular, the closed prefix relation clarifies what program transformations are allowed. This helps us define open floating.%mdk%mdk

\item{}
We give a definition of the open floating algorithm,
which floats up redundant $\mathpre{\mathkw{open}}$s (Section~\mdref{sec-floating}{4}) by analyzing the effect type of expressions.%mdk%mdk

\item{}
We implemented open floating in the Koka compiler~[\mdcite{leijen:kokarepo}{11}].%mdk%mdk

\item{}
We evaluated open floating via a preliminary benchmark (Section~\mdref{sec-bench}{5}),
which improved performance by 2.5\ensuremath{\times}.
Based on the results, we make it clear what kind of programs benefit from open floating.%mdk%mdk
%mdk
\end{itemize}%mdk

\noindent We discuss future work in Section~\mdref{sec-future}{6} and related work in Section~\mdref{sec-related}{7}.%mdk

\section{2.\hspace*{0.5em}Overview}\mdlabel{sec-overview}{2}%mdk%mdk

\noindent In this section, we give an overview of this thesis.
We first give an overview of the calculus of study, and explain the need for $\mathpre{\mathkw{open}}$.
We then show an example with redundant $\mathpre{\mathkw{open}}$s and describe the idea of our solution.%mdk

\subsection{2.1.\hspace*{0.5em}Effect Handlers}\mdlabel{sec-handlers}{2.1}%mdk%mdk

\noindent Algebraic effects are declared with an effect label $\mathpre{\mathid{l}}$ and a list of operation signatures.
For instance, suppose we have a $\mathpre{\mathid{read}}$ effect with a single operation $\mathpre{\mathid{ask}}$, which takes a unit argument and returns an integer value.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{read}~\xcolon{}~\{~\mathid{ask}~\xcolon{}~()~{\rightarrow}~\mathid{int}~\}
\end{mdmathpre}%mdk
\]%mdk
\noindent An effect handler for $\mathpre{\mathid{read}}$ specifies what the $\mathpre{\mathid{ask}}$ operation should do when it is called
in the handled expression.
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{ask}~{\rightarrow}~\lambda \_.~\lambda \mathid{k}.~\mathid{k}~3~\}~\lambda \_.~\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{ask}~()
\end{mdmathpre}%mdk
\]%mdk
\noindent In this example, $\mathpre{\mathkw{perform}~\mathid{ask}~()}$ calls operation $\mathpre{\mathid{ask}}$ with argument $\mathpre{()}$,
which is evaluated to $\mathpre{3}$ according to the handler.
The behavior of an operation call is formalized as follows:
(1) find the innermost handler of the effect,
(2) capture the \emph{resumption} \textendash{} continuation delimited by the handler \textendash{}, and
(3) apply the handler clause to the argument and the resumption.

\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

\item$\mathpre{\underline{\mathkw{handler}~\{~\mathid{ask}~{\rightarrow}~\lambda \_.~\lambda \mathid{k}.~\mathid{k}~3~\}}~\lambda \_.~\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{ask}~()}$%mdk

\item$\mathpre{\mathid{resume}~=~\gray{\lambda \mathid{z}.}\mathkw{handler}~\{~\mathid{ask}~{\rightarrow}~\lambda \_.~\lambda \mathid{k}.~\mathid{k}~3~\}~\lambda \_.~\gray{\mathid{z}}~+~\mathkw{perform}~\mathid{ask}~()}$%mdk

\item$\mathpre{(\lambda \_.~\lambda \mathid{k}.~\mathid{k}~3)~()~~\mathid{resume}}$%mdk
%mdk
\end{enumerate}%mdk

\noindent The handler resumes the resumption with argument $\mathpre{3}$, so that the example is evaluated to the following.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{ask}~{\rightarrow}~\lambda \_.~\lambda \mathid{k}.~\mathid{k}~3~\}~\lambda \_.~3~+~\mathkw{perform}~\mathid{ask}~()
\end{mdmathpre}%mdk
\]%mdk
\noindent The two occurrences of $\mathpre{\mathkw{perform}~\mathid{ask}~()}$ are both evaluated to $\mathpre{3}$, therefore the whole expression is evaluated to $\mathpre{6}$.

Using effect handlers, it is easy to combine different effects in a single program.
Let us combine $\mathpre{\mathid{read}}$ with the exception effect $\mathpre{\mathid{exn}}$, which has an operation $\mathpre{\mathid{throw}}$ of type $\mathpre{\forall \alpha{}.\mathid{int}~{\rightarrow}~\alpha{}}$%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{exn}~\xcolon{}~\{~\mathid{throw}~\xcolon{}~\forall \alpha{}.\mathid{int}~{\rightarrow}~\alpha{}~\}
\end{mdmathpre}%mdk
\]%mdk
\noindent Using a handler for $\mathpre{\mathid{exn}}$ as we did for $\mathpre{\mathid{read}}$, we can perform the $\mathpre{\mathid{throw}}$ operation.
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{k}~3~\}~(\lambda \_.\\
\mdmathindent{2}\mathkw{handler}~\{~\mathid{throw}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{x}~\}~(\lambda\_.\\
\mdmathindent{4}\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{throw}\,~1))
\end{mdmathpre}%mdk
\]%mdk
\noindent In this program, $\mathpre{\mathkw{perform}~\mathid{ask}~()}$ is evaluated to $\mathpre{3}$ as before,
but the entire expression is evaluated to $\mathpre{1}$ due to $\mathpre{\mathkw{perform}~\mathid{throw}\,~1}$.
The handler for the $\mathpre{\mathid{throw}}$ operation discards the resumption $\mathpre{\mathid{k}}$ and returns the argument $\mathpre{\mathid{x}}$,
which exits the computation out of the handler expression.

\subsection{2.2.\hspace*{0.5em}Evidence Passing Semantics and Row-based Effect System}\mdlabel{sec-evidence-passing-semantics-and-row-based-effect-system}{2.2}%mdk%mdk

\noindent Among different formalizations of the dynamic semantics of effect handlers, we adopt
the \emph{evidence passing semantics} (EPS)~[\mdcite{xie:gep}{20}], which exploits the invariants derived from the row-based effect system and
allows the compiler to translate programs to efficient code.%mdk

Under the EPS,
we pass all handlers in scope to the handled expression
so that operation calls can access their handler locally.
The operation clauses passed to expressions are represented as an \emph{evidence vector}~[\mdcite{xie2020effect}{19}].
For instance, in the $\mathpre{\mathid{read}}$ and $\mathpre{\mathid{exn}}$ examples discussed above, the expression $\mathpre{\mathkw{perform}~\mathid{ask}~()}$ is performed
with the evidence vector of the form $\mathpre{\llangle{}\mathid{exn}\xcolon{}~\{\mathid{throw}~{\mapsto}~{\dots}\},~\mathid{read}\xcolon{}~\{\mathid{ask}~{\mapsto}~{\dots}~\}\rrangle{}}$.
Xie and Leijen~[\mdcite{xie:gep}{20}] show that EPS often allow us to avoid lookups and resumption captures, which are one of
main sources of inefficiency in effect handler execution.%mdk

The static semantics of our calculus is defined by a \emph{row-based effect system}.
In the effect system, every expression is related to an effect row type in addition to a usual type.
Effect rows indicate what kind of evidence vector is provided from the context to evaluate the expression.
For instance, in the example with $\mathpre{\mathid{read}}$ and $\mathpre{\mathid{exn}}$,
the expression $\mathpre{\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{throw}\,~1}$ has type $\mathpre{\mathid{int}}$ and effect row $\mathpre{\langle{}\mathid{exn},~\mathid{read}\,\rangle{}}$.%mdk

The typing rules maintain the correspondence between evidence vectors and effect rows.
For instance, a function application uses the same evidence vector for the function,
the argument, and the $\mathpre{\beta}$-reduced expression.
Correspondingly, the typing rule for function application requires
the effect rows of the three parts (occurrences of $\mathpre{{\epsilon}}$ in the premises)
to agree with that of the entire expression (occurrence of $\mathpre{{\epsilon}}$ in the conclusion).%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}_{1}~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}\midbar{}{\epsilon}~~~~~~~~~\Gamma{}~\vdash{}~\mathid{e}_{2}~\xcolon{}~\sigma_{1}\midbar{}{\epsilon}}{\Gamma{}~\vdash{}~\mathid{e}_{1}~\mathid{e}_{2}~\xcolon{}~\sigma_{2}\midbar{}{\epsilon}}{\brulename{\textsc{APP}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\noindent We ignore the order of labels in effect rows
(except for \emph{parameterized effect labels} that are discussed in Section~\mdref{sec-type}{3.1.2} and Section~\mdref{sec-prefix}{3.4}).
For instance, we regard two rows $\mathpre{\langle{}\mathid{exn},~\mathid{read}\,\rangle{}}$ and $\mathpre{\langle{}\mathid{read},~\mathid{exn}\,\rangle{}}$ as equivalent.
This flexible row equivalence allows the type system to ignore the order of handlers in evaluation contexts.
As a consequence, both programs below are judged well-typed as one would expect.%mdk
\begin{mdtabular}{2}{\dimeval{(\linewidth)/2}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{k}~3~\}~(\lambda \_.\\
\mdmathindent{2}\mathkw{handler}~\{~\mathid{throw}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{x}~\}~\mathid{f})
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{throw}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{x}~\}~(\lambda \_.\\
\mdmathindent{2}\mathkw{handler}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{k}~3~\}~\mathid{f})
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}
\noindent\[\begin{mdmathpre}%mdk
\text{where}\quad \mathid{f}~=~\lambda\_.\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{ask}~()~+~\mathkw{perform}~\mathid{throw}\,~1
\end{mdmathpre}%mdk
\]%mdk
\noindent We formally define the effect row equivalence in Section~\mdref{sec-type}{3.1.2} and
discuss it in Section~\mdref{sec-prefix}{3.4}.

\subsection{2.3.\hspace*{0.5em}Effect Type Adjustment for Function Types}\mdlabel{sec-effect-type-adjustment-for-function-types}{2.3}%mdk%mdk

\noindent The typing rule $\mathpre{\brulename{{APP}}}$ is too restrictive on some occasions.
Consider a function $\mathpre{\mathid{safediv}}$ of type $\mathpre{(\mathid{int},~\mathid{int})~{\rightarrow}~\total{}~\mathid{maybe}\langle{}\mathid{int}\,\rangle{}}$,
which returns $\mathpre{\mathid{Nothing}}$ if the divider is $\mathpre{0}$, instead of throwing an exception.
This function causes no effect, hence we should be able to call the function in any context.
However, the type system prevents us from calling $\mathpre{\mathid{safediv}}$ in certain contexts.
For instance, the following expression is judged ill-typed.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{k}~3~\}~\lambda\_.\mathid{safediv}(3,~2)
\end{mdmathpre}%mdk
\]%mdk
\noindent The expression $\mathpre{\mathid{safediv}(3,2)}$ expects an evidence vector of type $\mathpre{\total{}}$,
whereas the context provides an evidence vector of type $\mathpre{\langle{}\mathid{read}\,\rangle{}}$.
Due to this inconsistency, the expression is rejected by the type system.

To call functions with a \textquotedblleft{}smaller\textquotedblright{} effect, we introduce the expression $\mathpre{\mathkw{open}~{\epsilon}'~\mathid{v}}$ into the calculus.
At compile time, $\mathpre{\mathkw{open}}$ allows a function to have a \textquotedblleft{}bigger\textquotedblright{} effect type according to the following typing rule.%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}~~~~~~~~{\epsilon}~\prefix {\epsilon}'}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathkw{open}~{\epsilon}'~\mathid{v}~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}'~\sigma_{2}}{\brulename{\textsc{OPEN}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\noindent At runtime, $\mathpre{\mathkw{open}}$ adjusts evidence vectors so that the callee receives an evidence vector of the expected shape
and thus runs correctly.
Using $\mathpre{\mathkw{open}}$, we can make the above example well-typed.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\{\mathid{ask}~{\mapsto}~\lambda \mathid{x}.~\lambda \mathid{k}.~\mathid{k}~3\}~\lambda\_.(\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv})(3,~2)
\end{mdmathpre}%mdk
\]%mdk
\noindent We call the smaller effect row a \emph{closed prefix} of the larger one.
The closed prefix relation is defined as:
\noindent\[\begin{mdmathpre}%mdk
\langle{}\mathid{l}_1,{\dots},\mathid{l}_\mathid{n}\,\rangle{}~\prefix \langle{}\mathid{l}_1,{\dots},\mathid{l}_\mathid{n}\midbar{}{\epsilon}\,\rangle{}~\quad (\mathid{n}~\geq 0)
\end{mdmathpre}%mdk
\]%mdk
\noindent It turns out that different formulations are possible but some 
seemingly benign generalizations can make the type system unsound \textendash{}

we discuss the closed prefix relation in detail in Section~\mdref{sec-prefix}{3.4}.

\subsection{2.4.\hspace*{0.5em}Motivating Open Floating}\mdlabel{sec-motivating-open-floating}{2.4}%mdk%mdk

\noindent Our calculus is designed as an intermediate language of a compiler.
This means the user does not need to explicitly write $\mathpre{\mathkw{open}}$s; they are automatically inserted by the type inferencer.
The user expression $\mathpre{\mathkw{handler}~\{~\mathid{ask}~{\mapsto}~{\dots}~\}~\lambda\_.\mathid{safediv}(3,2)}$ is translated to
explicitly typed $\mathpre{\mathkw{handler}^{\total{}}~\{~\mathid{ask}~{\mapsto}~{\dots}~\}~\lambda\_.(\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv})~(3,2)}$, for example.%mdk

Unfortunately, naive insertion of $\mathpre{\mathkw{open}}$s makes programs inefficient.
Consider a program that calls $\mathpre{\mathid{safediv}}$ three times.
The compiler inserts $\mathpre{\mathkw{open}}$s into each function call as follows.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}^{\total{}}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}\xcolon{}\mathid{int}.~\lambda \mathid{k}\xcolon{}\mathid{int}~{\rightarrow}~\total{}~\mathid{int}.~\mathid{k}~3~\}~\lambda\_.\\
\mdmathindent{2}\mathkw{let}~\mathid{x}~=~\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv}(3,2)~\mathkw{in}\\
\mdmathindent{2}\mathkw{let}~\mathid{y}~=~\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv}(3,\mathid{x})~\mathkw{in}\\
\mdmathindent{2}\mathkw{open}~\langle{}\mathid{read}\,\rangle{}~\mathid{safediv}(3,~\mathid{y})
\end{mdmathpre}%mdk
\]%mdk
\noindent As $\mathpre{\mathkw{open}}$ causes evidence vector adjustment at runtime, having many $\mathpre{\mathkw{open}}$ calls makes execution slow.
In order to avoid this inefficiency, we design the \emph{open floating} optimization
that eliminates redundant $\mathpre{\mathkw{open}}$ calls.
By open floating, the above program is transformed to the following one.
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}^{\total{}}~\{~\mathid{ask}~{\mapsto}~\lambda \mathid{x}\xcolon{}\mathid{int}.~\lambda \mathid{k}\xcolon{}\mathid{int}~{\rightarrow}~\total{}~\mathid{int}.~\mathid{k}~3~\}~\lambda^{\langle{}\mathid{read}\,\rangle{}}\_.\\
\mdmathindent{2}\mathkw{restrict}~\total{}~(\\
\mdmathindent{4}\mathkw{let}~\mathid{x}~=~\mathid{safediv}(3,2)~\mathkw{in}\\
\mdmathindent{4}\mathkw{let}~\mathid{y}~=~\mathid{safediv}(3,\mathid{x})~\mathkw{in}\\
\mdmathindent{4}\mathid{safediv}(3,~\mathid{y}))
\end{mdmathpre}%mdk
\]%mdk
\noindent Here, $\mathpre{\mathkw{restrict}~{\epsilon}~\mathid{e}}$ allows $\mathpre{\mathid{e}}$ to be typed with effect $\mathpre{{\epsilon}}$,
which is smaller than the effect of the context.
In this particular example, $\mathpre{\mathid{e}}$ is typed with $\mathpre{\total{}}$, not $\mathpre{\langle{}\mathid{read}\,\rangle{}}$.
At runtime, as $\mathpre{\mathkw{open}}$ does, $\mathpre{\mathkw{restrict}~{\epsilon}~\mathid{e}}$ changes the shape of the evidence vector to fit $\mathpre{{\epsilon}}$
and pass it to $\mathpre{\mathid{e}}$.

In general, open floating erases $\mathpre{\mathkw{open}}$ in a $\mathpre{\beta{}}$-redex and
re-assigns appropriate $\mathpre{\mathkw{open}}$ or $\mathpre{\mathkw{restrict}}$ to make the whole expression type check in a bottom-up way.
The closed prefix relation plays an essential role in determining the new effect type of each sub-expression.

We formally define $\mathpre{\mathkw{open}}$, $\mathpre{\mathkw{restrict}}$, and the closed prefix relation in Section~\mdref{sec-fpwo}{3},
present the open floating algorithm in Section~\mdref{sec-floating}{4}, and discuss a preliminary benchmark in Section~\mdref{sec-bench}{5}.%mdk


\section{3.\hspace*{0.5em}System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$}\mdlabel{sec-fpwo}{3}%mdk%mdk

\noindent In this section, we present System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$, a calculus with algebraic effect handlers and the $\mathpre{\mathkw{open}}$.
The calculus is an extension of System $\mathpre{\mathsf{F}_{\mathid{pw}}}$~[\mdcite{xie:gep}{20}], an explicitly typed polymorphic lambda calculus with effect handlers.
The semantics is based on \emph{evidence passing semantics}~[\mdcite{xie:gep}{20}], which leads to an efficient implementation of effect handlers.
Furthermore, both calculi have row-based effect types, which denote the static meaning of evidence vectors.
We extend $\mathpre{\mathsf{F}_{\mathid{pw}}}$ with $\mathpre{\mathkw{open}}$, $\mathpre{\mathkw{restrict}}$ and parameterized effect labels.
These features have previously been discussed by~Leijen~[\mdcite{leijen:algeff}{10}].
In that work, the idea of $\mathpre{\mathkw{open}}$ was formalized as a typing rule,
and parameterized effect labels were formalized in a way that does not fit well
to our calculus.%mdk

We have confirmed the soundness of the type system through the compiler implementation.
We are currently developing formal proofs.
We first introduce the syntax, dynamic semantics, and static semantics of $\mathpre{\mathsf{F}_{\mathid{pwo}}}$.
After that, we describe the typing with effect rows, including the closed prefix relation.
Effect typing plays an important role in this study,
since open floating depends heavily on it.%mdk

\subsection{3.1.\hspace*{0.5em}Syntax}\mdlabel{sec-syntax}{3.1}%mdk%mdk

\noindent The syntax is defined in Figure~\mdref{fig-syntax}{\mdcaptionlabel{1}}.%mdk

\begin{figure}[t]%mdk
\begin{mdflushleft}%mdk
\begin{mdtabular}{2}{\dimeval{(\linewidth-\dimwidth{0.45})/1}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{vertical-align=top,width=\dimwidth{0.45}}%mdk
\begin{mdtabular}{4}{\dimeval{(\linewidth)/4}}{1ex}%mdk
\begin{tabular}{lrll}
Expression&$\mathpre{\mathid{e}}$&::=&$\mathpre{\mathid{v}}$ \textbar{}  $\mathpre{\mathid{e}~\mathid{e}}$ \textbar{} $\mathpre{\mathid{e}~{\sigma}}$\\
&&\textbar{}&$\mathpre{\mathkw{let}~\mathid{x}~=~\mathid{e}~\mathkw{in}~\mathid{e}}$\\
&&\textbar{}&\mdinline{padding-top=0.2ex,padding-right=0ex,padding-bottom=0.2ex,padding-left=0ex,background-color=\#DDDDDD}{$\mathpre{\mathkw{prompt}~\mathid{m}~\mathid{h}~\mathid{e}}$}\\
&&\textbar{}&\mdinline{padding-top=0.2ex,padding-right=0ex,padding-bottom=0.2ex,padding-left=0ex,background-color=\#DDDDDD}{$\mathpre{\mathkw{yield}~\mathid{m}~\mathid{v}}$} $\mathpre{\downstrut}$\\
&&\textbar{}&$\mathpre{\mathkw{restrict}~{\epsilon}~\mathid{e}}$\\
Value&$\mathpre{\mathid{v}}$&::=&$\mathpre{\mathid{x}}$ \textbar{}  $\mathpre{\lambda^{{\epsilon}}\mathid{x}\xcolon{}{\sigma}.~\mathid{e}}$\\
&&\textbar{}&$\mathpre{\Lambda \alpha{}^\mathsf{k}.~\mathid{v}}$\\
&&\textbar{}&$\mathpre{\mathkw{handler}^{\epsilon}~\mathid{h}}$\\
&&\textbar{}&$\mathpre{\mathkw{perform}~\mathid{op}~{\epsilon}~{\overline\sigma}\downstrut}$\\
&&\textbar{}&$\mathpre{\mathkw{open}~{\epsilon}~\mathid{v}}$\\
Hnd. clauses&$\mathpre{\mathid{h}}$&::=&$\mathpre{\{~\overline{\mathid{op}~{\mapsto}~\mathid{f}}~\}\downstrut}$\\
\end{tabular}\end{mdtabular}

\begin{mdblock}{padding=0.5ex,border-width=\dimpx{1},border-color=black,border-style=solid}%mdk
\begin{mdtabular}{2}{\dimeval{(\linewidth)/2}}{1ex}%mdk
\begin{tabular}{ll}
zero or more $\mathpre{\mathid{x}}$&$\mathpre{\overline{\mathid{x}}}$\\
internal constructs&\mdinline{padding-top=0.2ex,padding-right=0ex,padding-bottom=0.2ex,padding-left=0ex,background-color=\#DDDDDD}{$\mathpre{\text{internal}}$}\\
invariants&$\mathpre{\side{\text{invariants}}}$\\
\end{tabular}\end{mdtabular}%mdk
\end{mdblock}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{vertical-align=top,width=\dimavailable}%mdk
\begin{mdtabular}{4}{\dimeval{(\linewidth)/4}}{1ex}%mdk
\begin{tabular}{lrll}
Type&$\mathpre{{\sigma}}$&::=&$\mathpre{\alpha{}^{\mathsf{k}}}$ \textbar{} $\mathpre{\mathid{c}^{\mathsf{k}}~{\overline\sigma}}$ \textbar{} $\mathpre{{\sigma}~{\rightarrow}~~{\epsilon}~~{\sigma}}$\\
&&\textbar{}&$\mathpre{\forall \alpha{}^{\mathsf{k}}.~{\sigma}}$\\
Type in effect sig.&$\mathpre{{\tau}}$&::=&$\mathpre{{\sigma}}$ \textbar{} $\mathpre{\lambda \alpha{}^{*}.{\tau}}$\\
Kind&$\mathpre{\mathsf{k}}$&::=&$\mathpre{*}$  \textbar{} $\mathpre{\mathsf{k}~{\rightarrow}~\mathsf{k}}$ \textbar{} $\mathpre{\mathsf{lab}}$ \textbar{} $\mathpre{\mathsf{eff}\downstrut}$\\
Effect label&$\mathpre{\mathid{l}}$&::=&$\mathpre{{\sigma}^{\mathsf{lab}}}$\\
Effect constant&$\mathpre{{\mathid{c}_\mathid{l}}}$&::=&$\mathpre{\mathid{c}^{\mathsf{k}}}$\\
&&&$\mathpre{\side{\mathsf{k}~=~*~{\rightarrow}~{\dots}~{\rightarrow}~*~{\rightarrow}~\mathsf{lab}}}$\\
Effect row&$\mathpre{{\epsilon}}$&::=&$\mathpre{\total{}}$ \textbar{}  $\mathpre{{\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}}}$ \textbar{} $\mathpre{\alpha{}^\mathsf{eff}}$\\
Type env.&$\mathpre{\Gamma{}}$&::=&$\mathpre{\bullet{}}$ \hspace*{0.5ex}\textbar{}\hspace*{0.5ex} $\mathpre{\Gamma{},~\mathid{x}\xcolon{}{\sigma}}$\\
Effect ctx.&$\mathpre{\Sigma{}}$&::=&$\mathpre{\{~\overline{{\mathid{c}_\mathid{l}}\xcolon{}\mathid{sig}}~\}}$\\
Effect sig.&$\mathpre{\mathid{sig}}$&::=&$\mathpre{\{~\overline{\mathid{op}\xcolon{}\forall \overline{\alpha{}^{\mathsf{k}}}.~{\tau}~{\rightarrow}~{\tau}}~\}\downstrut}$\\
Evidence&$\mathpre{\mathid{ev}}$&::=&$\mathpre{(\mathid{m},~\mathid{h},~\mathid{w})}$\\
Evidence vec.&$\mathpre{\mathid{w}}$&::=&$\mathpre{\evec{}}$ \textbar{} $\mathpre{{\evec{\mathid{l}\xcolon{}\mathid{ev}\midbar{}\mathid{w}}}}$\\
\end{tabular}\end{mdtabular}%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{1}.}~\mdcaptiontext{Syntax of System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-syntax}{1}%mdk
%mdk
\end{figure}%mdk

\subsubsection{Expressions}\mdlabel{sec-expressions}{3.1.1}%mdk%mdk

\noindent Expressions $\mathpre{\mathid{e}}$ include values $\mathpre{\mathid{v}}$, applications $\mathpre{\mathid{e}~\mathid{e}}$, type applications $\mathpre{\mathid{e}~{\sigma}}$, let-bindings $\mathpre{\mathkw{let}~\mathid{x}~=~\mathid{e}~\mathkw{in}~\mathid{e}}$,
prompt $\mathpre{\mathkw{prompt}~\mathid{m}~\mathid{h}~\mathid{e}}$, yield $\mathpre{\mathkw{yield}~\mathid{m}~\mathid{v}}$, and restrict $\mathpre{\mathkw{restrict}~{\epsilon}~\mathid{e}}$.
Prompts and yields are \emph{internal constructs} that only appear as an intermediate result of evaluation.
We will give the definition of internal constructs in Definition~\mdref{internal}{1} more precisely.%mdk

Values $\mathpre{\mathid{v}}$ include variables $\mathpre{\mathid{x}}$, lambda abstractions $\mathpre{\lambda^{{\epsilon}}\mathid{x}\xcolon{}{\sigma}.\mathid{e}}$,
type abstractions $\mathpre{\Lambda \alpha{}^\mathsf{k}.\mathid{v}}$, effect handlers $\mathpre{\mathkw{handler}^{\epsilon}~\mathid{h}}$, operation calls $\mathpre{\mathkw{perform}~\mathid{op}~{\epsilon}~{\overline\sigma}}$,
and open $\mathpre{\mathkw{open}~{\epsilon}~\mathid{v}}$.%mdk

Handlers clauses $\mathpre{\mathid{h}}$ consist of a sequence of pairs of an operation name $\mathpre{\mathid{op}}$ and a function value $\mathpre{\mathid{f}}$.
The meta-variable $\mathpre{\mathid{f}}$ is syntactically a value, but we use it specifically as a function, which takes (type) arguments.
The type system maintains the intention.%mdk

\subsubsection{Types}\mdlabel{sec-type}{3.1.2}%mdk%mdk

\noindent Types $\mathpre{{\sigma}}$ include type variables $\mathpre{\alpha{}^\mathsf{k}}$ of kind $\mathpre{\mathsf{k}}$,
type application for type constructors $\mathpre{\mathid{c}^\mathsf{k}~{\overline\sigma}}$ (where $\mathpre{\mathid{c}^\mathsf{k}}$ is applied to arguments $\mathpre{{\overline\sigma}}$),
function types $\mathpre{\sigma_{1}~{\rightarrow}{\epsilon}~\sigma_{2}}$ (indicating the body of the function can cause effect $\mathpre{{\epsilon}}$), and
polymorphic types $\mathpre{\forall \alpha{}^\mathsf{k}.{\sigma}}$.\mdfootnote{1}{\noindent Kind annotations directly relate their types to the specific symbols associated with them, such as $\mathpre{\mu{}}$ and $\mathpre{{\mathid{c}_\mathid{l}}}$. This allows us to use these symbols just as aliases.%mdk
\mdlabel{fn-fnkindannot}{1}%mdk%mdk
}
By \emph{extending} $\mathpre{{\sigma}}$ with type-level lambdas, we obtain a set of types $\mathpre{{\tau}}$ that appear in effect signatures. Effect signatures are explained later in this section.%mdk



Kinds $\mathpre{\mathsf{k}}$ include the regular kind $\mathpre{*}$, functions $\mathpre{\mathsf{k}{\rightarrow}\mathsf{k}}$,
effect labels $\mathpre{\mathsf{lab}}$, and effect rows $\mathpre{\mathsf{eff}}$.
Types of the function kind $\mathpre{\mathsf{k}{\rightarrow}\mathsf{k}}$ are either an effect constant $\mathpre{{\mathid{c}_\mathid{l}}}$, a row type constructor $\mathpre{\langle{}\_\midbar{}\_\,\rangle{}}$,
or a type $\mathpre{{\tau}}$ in an effect signature.
Effect labels $\mathpre{\mathid{l}}$ are types of kind $\mathpre{\mathsf{lab}}$.

Effect constants $\mathpre{\mathid{c}_\mathid{l}}$ are of kind $\mathpre{\mathsf{lab}}$ parameterized with zero or more types of regular kind.
Effect labels are used to structure effect rows and evidence vectors, while
effect constants are used for effect contexts and effect labels.%mdk

Effect rows $\mathpre{{\epsilon}}$ include the empty effect $\mathpre{\total{}}$, extension with effect label $\mathpre{\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}}$,
and type variables $\mathpre{\alpha{}^\mathsf{eff}}$ of kind $\mathpre{\mathsf{eff}}$.
We use the following abbreviation for rows: $\mathpre{\langle{}\mathid{l}_{1},{\dots},\mathid{l}_\mathid{n}\midbar{}{\epsilon}\,\rangle{}~\doteq{}~\langle{}\mathid{l}_{1}\midbar{}{\dots}~\langle{}~\mathid{l}_\mathid{n}\midbar{}{\epsilon}~\,\rangle{}~{\dots}~\,\rangle{}}$
and $\mathpre{\langle{}\mathid{l}_{1},~{\dots},~\mathid{l}_\mathid{n}\,\rangle{}~\doteq{}~\langle{}\mathid{l}_{1},{\dots},\mathid{l}_\mathid{n}\midbar{}\total{}~\,\rangle{}}$. 
We use $\mathpre{\mu{}}$ to denote type variable of kind $\mathpre{\mathsf{eff}}$.
The equivalence of effect rows is defined in Figure~\mdref{fig-row}{\mdcaptionlabel{2}}. We can ignore the order of occurrences of two effect labels
in a row if two labels consist of different effect constants.
See Section~\mdref{sec-prefix}{3.4} for details of effect rows.%mdk



An effect context $\mathpre{\Sigma{}}$ is a sequence of pairs of an effect constant and an effect signature.
It maintains the relation between the name of an effect and the type of its operations.
We assume $\mathpre{\Sigma{}}$ is given externally in this calculus, while in practical language one may define $\mathpre{\Sigma{}}$
by top-level definitions.%mdk

Effect signatures $\mathpre{\mathid{sig}}$ are a sequence of a pair of an operation name and its type.
The type $\mathpre{{\tau}}$ in an effect signature takes zero or more type arguments of regular kind.
The type arguments will be passed if the effect is parameterized.
We will show an example with type rule $\mathpre{\brulename{{PERFORM}}}$ in Section~\mdref{sec-static}{3.3}.%mdk

\subsubsection{Evidence Vectors}\mdlabel{sec-evidence-vectors}{3.1.3}%mdk%mdk

\noindent Evidence vectors $\mathpre{\mathid{w}}$ include the empty vector $\mathpre{\llangle{}\rrangle{}}$ and
extension $\mathpre{\llangle{}\mathid{l}\xcolon{}\mathid{ev}\midbar{}\mathid{w}\rrangle{}}$ with a pair of an effect label $\mathpre{\mathid{l}}$ and an evidence $\mathpre{\mathid{ev}}$.
Evidences $\mathpre{\mathid{ev}}$ are a triple $\mathpre{(\mathid{m},~\mathid{h},~\mathid{w})}$ of a marker $\mathpre{\mathid{m}}$, a handler $\mathpre{\mathid{h}}$, and an evidence vector $\mathpre{\mathid{w}}$
where $\mathpre{\mathid{h}}$ is defined.
The evidence vector in the triple is key to general use of effect handlers, but the discussion is out of
the scope of this paper. See~[\mdcite{xie:gep}{20}] for details.%mdk

\begin{figure}[tbp]%mdk
\begin{mdflushleft}%mdk
\begin{mdtabular}{3}{\dimeval{(\linewidth-\dimwidth{0.25})/2}}{0pt}%mdk
\begin{tabular}{lll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.25}}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{}{{\epsilon}~{\,\cong\,}~{\epsilon}}{\brulename{\textsc{EQ-REFL}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\epsilon_{1}~{\,\cong\,}~\epsilon_{2}~~~\epsilon_{2}~{\,\cong\,}\epsilon_{3}}{\epsilon_{1}~{\,\cong\,}\epsilon_{3}}{\brulename{\textsc{EQ-TRANS}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\epsilon_{1}~{\,\cong\,}~\epsilon_{2}}{\langle{}\mathid{l}\midbar{}\epsilon_{1}\,\rangle{}~{\,\cong\,}~\langle{}\mathid{l}\midbar{}\epsilon_{2}\,\rangle{}}{\brulename{\textsc{EQ-HEAD}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}
%mdk-begin-texraw
\vspace{-2em}
\begin{mdtabular}{2}{\dimeval{(\linewidth)/2}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{l}_{1}~{\not\equiv}~\mathid{l}_{2}}{\langle{}\mathid{l}_{1}\midbar{}\langle{}\mathid{l}_{2}\midbar{}{\epsilon}\rangle\rangle {\,\cong\,}~\langle{}\mathid{l}_{2}\midbar{}\langle{}\mathid{l}_{1}\midbar{}{\epsilon}\rangle\rangle}{\brulename{\textsc{EQ-SWAP}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{{\mathid{c}_\mathid{l}}_1~\not =~{\mathid{c}_\mathid{l}}_2}{{\mathid{c}_\mathid{l}}_1~{\overline\sigma}_1~{\not\equiv}~{\mathid{c}_\mathid{l}}_2~{\overline\sigma}_2}{\brulename{\textsc{UNEQ-LAB}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{2}.}~\mdcaptiontext{Effect Row Type Equivalence}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-row}{2}%mdk
%mdk
\end{figure}%mdk

\subsection{3.2.\hspace*{0.5em}Dynamic Semantics}\mdlabel{sec-dynamic-semantics}{3.2}%mdk%mdk

\begin{figure}[h!]%mdk
\begin{mdflushleft}%mdk

\noindent Evaluation Contexts:%mdk
\begin{mdtabular}{3}{\dimeval{(\linewidth)/3}}{1ex}%mdk
\begin{tabular}{rll}
$\mathpre{\mathsf{E}}$&::=&$\mathpre{\hole{}~\mid \mathsf{E}~\mathid{e}~\mid \mathid{v}~\mathsf{E}~\mid \mathsf{E}~{\sigma}~\mid \mathkw{let}~\mathid{x}~=~\mathsf{E}~\mathkw{in}~\mathid{e}~\mid \mathkw{prompt}~\mathid{m}~\mathid{h}~\mathsf{E}~\mid \mathkw{restrict}~{\epsilon}~\mathsf{E}}$\\
$\mathpre{\mathsf{F}}$&::=&$\mathpre{\hole{}~\mid \mathsf{F}~\mathid{e}~\mid \mathid{v}~\mathsf{F}~\mid \mathsf{F}~{\sigma}~\mid \mathkw{let}~\mathid{x}~=~\mathsf{F}~\mathkw{in}~\mathid{e}}$\\
\end{tabular}\end{mdtabular}

\begin{mdbmargintb}{}{-1.5em}%mdk
\noindent Evaluation Steps:%mdk
\end{mdbmargintb}%mdk
\begin{mdtabular}{3}{\dimeval{(\linewidth)/3}}{0pt}%mdk
\begin{tabular}{lll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{e}~~{\longrightarrow}~~\mathid{e}'}{\mathid{w}~\vdash{}~\mathsf{F}[\mathid{e}]~{\longmapsto}~\mathsf{F}[\mathid{e}']}{(\mathid{step})}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{w}~\vdash{}~\mathid{e}~~{\longrightarrow}~~\mathid{e}'}{\mathid{w}~\vdash{}~\mathsf{F}[\mathid{e}]~{\longmapsto}~~\mathsf{F}[\mathid{e}']}{(\mathid{stepw})}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\quad\strut}{\mathid{w}~\vdash{}~\mathid{e}~{\longmapsto^*}~\mathid{e}}{(*\mathid{stepwR})}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}
%mdk-begin-texraw
\vspace{-2em}
\begin{mdtabular}{2}{\dimeval{(\linewidth-\dimwidth{0.65})/1}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.65}}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\ins{\mathid{l}}{(\mathid{m},\mathid{h},\mathid{w})}{\mathid{w}}~\vdash{}~~\mathid{e}~~{\longmapsto}~~\mathid{e}'}{\mathid{w}~\vdash{}~\mathsf{F}[\mathkw{prompt}~\mathid{m}~\mathid{h}~\mathid{e}]~{\longmapsto}~\mathsf{F}[\mathkw{prompt}~\mathid{m}~\mathid{h}~\mathid{e}']}{(\mathid{promptw})}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\side{\mathkw{restrict}~{\epsilon}'~\mathid{e}~\xcolon{}~{\sigma}\midbar{}{\epsilon}~~\quad {\epsilon}'\prefix {\epsilon}~\quad \vdash{}~\mathid{w}~\xcolon{}~{\epsilon}}~\\{}\mathid{select}~{\epsilon}'~\mathid{w}~\vdash{}~~\mathid{e}~~{\longmapsto}~~\mathid{e}'}{\mathid{w}~\vdash{}~\mathsf{F}[\mathkw{restrict}~{\epsilon}'~\mathid{e}]~{\longmapsto}~\mathsf{F}[\mathkw{restrict}~{\epsilon}'~\mathid{e}']}{(\mathid{restrictw})}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{w}~\vdash{}~\mathid{e}~{\longmapsto^*}~\mathid{e}'~\quad  \mathid{w}~\vdash{}~\mathid{e}'~{\longmapsto}~\mathid{e}''}{\mathid{w}~\vdash{}~\mathid{e}~{\longmapsto^*}~\mathid{e}''}{(*\mathid{stepwT})}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\begin{mdbmargintb}{}{-2em}%mdk
\noindent Evidence Vector Operations:%mdk
\end{mdbmargintb}%mdk
\begin{mdtabular}{2}{0pt}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{vertical-align=top,width=\dimwidth{0.55}}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{select}~\total{}~\mathid{w}~~~~~~~&~=~\llangle{}\rrangle{}\\
\mathid{select}~\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}~\mathid{w}~~&~=~\llangle{}\mathid{l}~\xcolon{}~\mathid{w}.\mathid{l}\midbar{}\mathid{select}~{\epsilon}~(\mathid{w}-\mathid{l})~\rrangle{}
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{vertical-align=top,width=\dimwidth{0.45}}%mdk
\noindent\[\begin{mdmathpre}%mdk
\llangle{}\mathid{l}~\xcolon{}~\mathid{ev}\midbar{}\mathid{w}\rrangle{}.\mathid{l}~&=~\mathid{ev}~~~~~~~~~~~~~~~~&\\
\llangle{}\mathid{l}_{1}~\xcolon{}~\mathid{ev}\midbar{}\mathid{w}\rrangle{}.\mathid{l}_{2}~&=~\mathid{w}.\mathid{l}_{2}~~~~~~~~~~~~&~\text{if}~\mathid{l}_{1}~\not =~\mathid{l}_{2}
\end{mdmathpre}%mdk
\]%mdk

\noindent\[\begin{mdmathpre}%mdk
\llangle{}\mathid{l}~\xcolon{}~\mathid{ev}\midbar{}\mathid{w}\rrangle{}~-~\mathid{l}~&=~\mathid{w}~~~~~~~~~~~~~~~~&\\
\llangle{}\mathid{l}_{1}~\xcolon{}~\mathid{ev}\midbar{}\mathid{w}\rrangle{}~-~\mathid{l}_{2}~&=~\mathid{w}~-~\mathid{l}_{2}~~~~~~~~~~~~&~\text{if}~\mathid{l}_{1}~\not =~\mathid{l}_{2}
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\noindent Reduction Rules:%mdk
\begin{mdtabular}{4}{\dimeval{(\linewidth)/4}}{1ex}%mdk
\begin{tabular}{llll}
$\mathpre{(\mathid{app})}$&$\mathpre{(\lambda^{{\epsilon}}\mathid{x}\xcolon{}{\sigma}.~\mathid{e})~\mathid{v}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{\mathid{e}[\mathid{x}{:\!=}\mathid{v}]~}$\\
$\mathpre{(\mathid{let})}$&$\mathpre{\mathkw{let}~\mathid{x}~=~\mathid{v}~\mathkw{in}~\mathid{e}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{\mathid{e}[\mathid{x}{:\!=}\mathid{v}]~}$\\
$\mathpre{(\mathid{tapp})}$&$\mathpre{(\Lambda \alpha{}^\mathsf{k}.~\mathid{v})~{\sigma}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{\mathid{v}[\alpha{}{:\!=}{\sigma}]}$\\
$\mathpre{(\mathid{handler})}$&$\mathpre{{\mathkw{handler}^{\epsilon}~\mathid{h}~\mathid{f}}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{{\mathkw{prompt}~\mathid{m}~\mathid{h}~~(\mathid{f}~())~}}$ \hspace*{1em}  with unique $\mathpre{\mathid{m}}$\\
$\mathpre{(\mathid{promptv})}$&$\mathpre{{\mathkw{prompt}~\mathid{m}~\mathid{h}~~\mathid{v}}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{\mathid{v}}$\\
$\mathpre{(\mathid{perform})}$&$\mathpre{{\mathid{w}~\vdash{}~\mathkw{perform}~\mathid{op}\,~\epsilon_{0}~{\overline\sigma}~\mathid{v}}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{{\mathkw{yield}~\mathid{m}~(\lambda^{\side{{\epsilon}}}\mathid{k}\side{\xcolon{}(\sigma_{2}~{\overline{\sigma'}})[\overline{\alpha}{:\!=}{\overline\sigma}]~{\rightarrow}~{\epsilon}~{\sigma}}.~\mathid{f}~{\overline\sigma}~\mathid{v}~\mathid{k})}}$\\
&&with&$\mathpre{{(\mathid{m},\mathid{h},\_)~=~\mathid{w}.\mathid{l}~~\wedge{}~(\mathid{op}~{\mapsto}~\mathid{f})~\in \mathid{h}}~\quad \side{\mathid{l}~=~{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}}}$\\
&&&$\mathpre{{\side{(\mathid{op}\xcolon{}\forall \overline{\alpha}.~{\sigma}_{\mathid{in}}~{\rightarrow}~{\sigma}_{\mathid{out}})\in \Sigma{}({\mathid{c}_\mathid{l}})~\wedge \bullet{}~\vdash{}~\mathid{h}~\xcolon{}~{\sigma}\midbar{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}}}}$\\
$\mathpre{(\mathid{prompt})}$&$\mathpre{{\mathkw{prompt}~\mathid{m}~\mathid{h}~~\mathsf{E}[\mathkw{yield}~\mathid{m}~\mathid{f}]}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{\mathid{f}~(\lambda^{\side{{\epsilon}}}\mathid{x}\side{\xcolon{}\sigma_{2}}.~\mathkw{prompt}~\mathid{m}~\mathid{h}~~\mathsf{E}[\mathid{x}])}$\\
&&with&$\mathpre{{\side{\bullet{}~\!\vdash_{\!\textsf{val}}~\mathid{f}~\xcolon{}~(\sigma_{2}~{\rightarrow}~{\epsilon}~{\sigma})~{\rightarrow}~{\epsilon}~{\sigma}}}}$\\
$\mathpre{(\mathid{open})}$&$\mathpre{(\mathkw{open}~{\epsilon}'~\mathid{f})~\mathid{v}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{\mathkw{restrict}~{\epsilon}~(\mathid{f}~\mathid{v})}$\\
&&with&$\mathpre{{\epsilon}~=~\mathid{effectof}(\mathid{f})}$ \hspace*{1em} $\mathpre{{~\side{\bullet{}~\vdash{}~\mathid{f}~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}}}}$\\
$\mathpre{(\mathid{restrictv})}$&$\mathpre{\mathkw{restrict}~{\epsilon}~\mathid{v}}$&$\mathpre{{\longrightarrow}}$&$\mathpre{\mathid{v}}$\\
\end{tabular}\end{mdtabular}

\begin{mdbmargintb}{}{-1.0em}%mdk
\noindent Effect Annotation Extractor:%mdk
\end{mdbmargintb}%mdk
\begin{mdtabular}{2}{\dimeval{(\linewidth)/2}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{effectof}(\lambda^{\epsilon}~\mathid{x}\xcolon{}{\sigma}.\mathid{e})~~~&=~{\epsilon}\\
\mathid{effectof}(\mathkw{handler}^{\epsilon}~\mathid{h})~~~~~~&=~{\epsilon}
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{effectof}(\mathkw{perform}~{\epsilon}~{\overline\sigma}~\mathid{op})~~&=~{\epsilon}
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}


\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{3}.}~\mdcaptiontext{Dynamic Semantics of System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-eval}{3}%mdk
%mdk
\end{figure}%mdk

\noindent The dynamic semantics is defined in Figure~\mdref{fig-eval}{\mdcaptionlabel{3}}.
The semantics consists of three rules: stepping $\mathpre{{\longmapsto}}$, multi-stepping $\mathpre{{\longmapsto^*}}$, and reduction $\mathpre{{\longrightarrow}}$.%mdk

\subsubsection{Evaluation Steps}\mdlabel{sec-evaluation-steps}{3.2.1}%mdk%mdk

\noindent The rules $\mathpre{(*\mathid{stepwR})}$ and $\mathpre{(*\mathid{stepwT})}$ defines multi-stepping as the reflexive transitive closure of stepping.
The rules $\mathpre{(\mathid{step})}$ and $\mathpre{(\mathid{stepw})}$ reduce a redex without and with an evidence vector $\mathpre{\mathid{w}}$, respectively.
In these rules, the evaluation context of the redex must be $\mathpre{\mathsf{F}}$, not $\mathpre{\mathsf{E}}$.
$\mathpre{\mathsf{F}}$ excludes prompt frames and restrict frames.%mdk

The $\mathpre{(\mathid{promptw})}$ rule extends the evidence vector.
Conversely, the $\mathpre{(\mathid{restrictw})}$ rule shortens the evidence vector using the $\mathpre{\mathid{select}}$ meta-function
so that the shape of the new evidence vector fits the effect row $\mathpre{{\epsilon}'}$ of the restrict frame.%mdk

\subsubsection{Reduction Rules}\mdlabel{sec-reduction-rules}{3.2.2}%mdk%mdk

\noindent The $\mathpre{(\mathid{app})}$, $\mathpre{(\mathid{let})}$ and $\mathpre{(\mathid{tapp})}$ rules are standard.
The $\mathpre{(\mathid{handler})}$ rule reduces a handler application by calling the passed function $\mathpre{\mathid{f}}$ under
$\mathpre{\mathkw{prompt}}$ with fresh marker $\mathpre{\mathid{m}}$. The marker acts as a control delimiter~[\mdcite{felleisen:prompt}{3}].
The $\mathpre{(\mathid{promptv})}$ rule removes the prompt frame if the handled expression is a value.%mdk

Operation call is divided into two rules: $\mathpre{(\mathid{perform})}$ and $\mathpre{(\mathid{prompt})}$.
The $\mathpre{(\mathid{perform})}$ rule prepares the marker $\mathpre{\mathid{m}}$ and handler clause $\mathpre{\mathid{f}}$ using the evidence vector.
In the right-hand side of the $\mathpre{(\mathid{prompt})}$,
the handler clause is applied to (type) arguments and wrapped by a lambda to take a resumption.
The $\mathpre{(\mathid{prompt})}$ rule captures the resumption $\mathpre{\lambda^{\side{{\epsilon}}}\mathid{x}\side{\xcolon{}\sigma_{2}}.~\mathkw{prompt}~\mathid{m}~\mathid{h}~~\mathsf{E}[\mathid{x}]}$
by finding the marker $\mathpre{\mathid{m}}$
and applies the operation clause to it, which is instantiated by the $\mathpre{(\mathid{perform})}$ rule.%mdk

The $\mathpre{(\mathid{open})}$ rule generates a restrict frame using the effect annotation of the function value.
Here, $\mathpre{\mathid{effectof}}$ meta-function is used to extract the effect type from the function value, which is
either a lambda abstraction, an operation call, or a handler.
The effect row of an open expression is used for type checking.
The $\mathpre{(\mathid{restrictv})}$ rule removes the restrict frame if the sub-expression is a value.%mdk


\subsection{3.3.\hspace*{0.5em}Static Semantics}\mdlabel{sec-static}{3.3}%mdk%mdk

\noindent The static semantics is mutually defined with three relations $\mathpre{\vdash{}}$, $\mathpre{\!\vdash_{\!\textsf{val}}}$, and $\mathpre{\!\vdash_{\!\textsf{ops}}}$ in Figure~\mdref{fig-static}{\mdcaptionlabel{4}}.%mdk

\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

\item$\mathpre{\Gamma{}~\vdash{}~\mathid{e}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}$ means expression $\mathpre{\mathid{e}}$ is typed $\mathpre{{\sigma}}$ under type environment $\mathpre{\Gamma{}}$ and contextual effect $\mathpre{{\epsilon}}$, i.e., the type of the evidence vector provided for evaluation of $\mathpre{\mathid{e}}$.%mdk

\item$\mathpre{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~\xcolon{}~{\sigma}}$ means value $\mathpre{\mathid{v}}$ is typed $\mathpre{{\sigma}}$ under type environment $\mathpre{\Gamma{}}$. Note that
if value $\mathpre{\mathid{v}}$ can be typed with $\mathpre{\!\vdash_{\!\textsf{val}}}$ relation,
then it can be typed with \emph{any} effect type $\mathpre{{\epsilon}}$ with $\mathpre{\vdash{}}$ relation, according to
type rule $\mathpre{\brulename{{VAL}}}$.%mdk

\item$\mathpre{\Gamma{}~\!\vdash_{\!\textsf{ops}}~\mathid{h}~\xcolon{}~{\sigma}\midbar{}\mathid{l}~\midbar{}{\epsilon}}$ means that the sequence of operation clauses $\mathpre{\mathid{h}}$ has return type $\mathpre{{\sigma}}$ and handles effect operation of label $\mathpre{\mathid{l}}$ under effect type $\mathpre{{\epsilon}}$.%mdk
%mdk
\end{itemize}%mdk

\noindent We also use well-formedness relation $\mathpre{\!\vdash_{\!\textsf{wf}}}$ and definitional equality of types $\mathpre{\!\vdash_{\!\textsf{eq}}}$ defined in Appendix.%mdk


Let us now look at the typing rules (Figure~\mdref{fig-static}{\mdcaptionlabel{4}}).
These rules are syntax directed in the sense that the syntax of the expressions determines the
applicable type rule.
The $\mathpre{\brulename{{VAL}}}$ rule types values as expressions with any effect type $\mathpre{{\epsilon}}$.
The $\mathpre{\brulename{{VAR}}}$ rule is usual.
The $\mathpre{\brulename{{ABS}}}$ rule type checks the body $\mathpre{\mathid{e}}$ with the effect annotation $\mathpre{{\epsilon}}$
of the lambda abstraction.
The $\mathpre{\brulename{{APP}}}$  is standard except for the effect type:
the operator ($\mathpre{\mathid{e}_{1}}$) and operand ($\mathpre{\mathid{e}_{2}}$) need to be typed under
the contextual effect of entire expression ($\mathpre{\mathid{e}_{1}~\mathid{e}_{2}}$).
Furthermore, the effect type of the body of the operator also needs to agree with the one of the entire expression.
The restriction guarantees that the evidence vector is passed correctly to sub-expressions.
This may seem too restrictive, but the open construct liberates the restriction.
The $\mathpre{\brulename{{BIND}}}$ rule is similar to the $\mathpre{\brulename{{APP}}}$ rule; both sub-expressions are required to be typed under the contextual effect $\mathpre{{\epsilon}}$.
The $\mathpre{\brulename{{TABS}}}$ and $\mathpre{\brulename{{TAPP}}}$ rules are standard except for bound type variables, which cannot have kind $\mathpre{\mathsf{lab}}$.%mdk

The $\mathpre{\brulename{{PERFORM}}}$ rule determines the type of the operation call referring to the
effect context $\mathpre{\Sigma{}}$ and the effect row $\mathpre{\langle{}\mathid{cl}\,~{\overline{\sigma'}}\midbar{}{\epsilon}\,\rangle{}}$.
The signature of the operation is found in the effect context and
the type arguments $\mathpre{{\overline\sigma}}$ are substituted for the type variables in the argument type $\mathpre{\tau_{1}}$ and the result type $\mathpre{\tau_{2}}$.
Furthermore, the type arguments $\mathpre{{\overline{\sigma'}}}$ from the effect row are applied to $\mathpre{\tau_{1}[\overline{\alpha}{:\!=}{\overline\sigma}]}$ and $\mathpre{\tau_{2}[\overline{\alpha}{:\!=}{\overline\sigma}]}$.%mdk

As an example, assuming $\mathpre{\Sigma{}~=~\{~\mathid{exn}~\xcolon{}~\{~\mathid{throw}~\xcolon{}~\forall \alpha{}.\mathid{string}~{\rightarrow}~\alpha{}~\}\}}$,
we can write $\mathpre{\lambda^{\langle{}\mathid{exn}\,\rangle{}}~\mathid{x}\xcolon{}\mathid{string}.~1~+~\mathkw{perform}~\mathid{throw}~\langle{}\mathid{exn}\,\rangle{}~\mathid{int}~\mathid{x}}$ as
a well-typed function. The operation call in the body is typed with
an instance of the $\mathpre{\brulename{{PERFORM}}}$ rule as follows.%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{throw}~\xcolon{}~\forall \beta{}.\mathid{string}~{\rightarrow}~\beta{}~\in \Sigma{}(\mathid{exn})\\\!\vdash_{\!\textsf{eq}}~\mathid{string}[\beta{}{:\!=}\mathid{int}]~{\equiv}~\mathid{string}~~~~~~~~~\!\vdash_{\!\textsf{eq}}~\beta{}[\beta{}{:\!=}\mathid{int}]~{\equiv}~\mathid{int}}{\mathid{x}~\xcolon{}~\mathid{string}~\!\vdash_{\!\textsf{val}}~\mathkw{perform}~\mathid{throw}~\langle{}\mathid{exn}\,\rangle{}~\mathid{int}~\xcolon{}~\mathid{string}~{\rightarrow}~\langle{}\mathid{exn}\,\rangle{}~\mathid{int}}{\brulename{\textsc{}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\noindent In this case, $\mathpre{{\mathid{c}_\mathid{l}}~=~\mathid{exn}}$ and $\mathpre{{\overline{\sigma'}}}$ is an empty sequence of types.
If we replace $\mathpre{\mathid{throw}}$ with $\mathpre{\mathid{polythrow}~\mathid{string}}$, $\mathpre{{\mathid{c}_\mathid{l}}~=~\mathid{polyexn}}$ and $\mathpre{{\overline{\sigma'}}}$ is a singleton sequence $\mathpre{\mathid{string}}$.%mdk

\begin{figure}[]%mdk
\begin{mdflushleft}%mdk
\begin{mdbmargintb}{}{-1ex}%mdk
\begin{mdblock}{padding=0.5ex,border-width=\dimpx{1},border-color=black,border-style=solid}%mdk
\noindent\[\begin{mdmathpre}%mdk
\Gamma{}~\vdash{}~\mathid{e}~\xcolon{}~{\sigma}\midbar{}{\epsilon}%\\
\quad\quad \Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~\xcolon{}~{\sigma}%\\
\quad\quad \Gamma{}~\!\vdash_{\!\textsf{ops}}~\mathid{h}~\xcolon{}~{\sigma}\midbar{}\mathid{l}\midbar{}{\epsilon}%
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdbmargintb}\begin{mdtabular}{2}{\dimeval{(\linewidth)/2}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~\xcolon{}~{\sigma}}{\Gamma{}~\vdash{}~\mathid{v}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}{\brulename{\textsc{VAL}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{x}~\xcolon{}~{\sigma}~\in \Gamma{}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{x}~\xcolon{}~{\sigma}}{\brulename{\textsc{VAR}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{},~~\mathid{x}\xcolon{}\sigma_{1}~\vdash{}~\mathid{e}~\xcolon{}~\sigma_{2}\midbar{}{\epsilon}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\lam{{\epsilon}}{\mathid{x}\xcolon{}\sigma_{1}}{\mathid{e}}~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}}{\brulename{\textsc{ABS}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}_{1}~\xcolon{}~\sigma_{1}~{\rightarrow}{\epsilon}~{\sigma}\midbar{}{\epsilon}~~~\Gamma{}~\vdash{}~\mathid{e}_{2}~\xcolon{}~\sigma_{1}\midbar{}{\epsilon}}{\Gamma{}~\vdash{}~\mathid{e}_{1}~\mathid{e}_{2}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}{\brulename{\textsc{APP}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}_{1}~\xcolon{}~\sigma_{1}\midbar{}{\epsilon}~~~~~~~\Gamma{},~\mathid{x}\xcolon{}\sigma_{1}~\vdash{}~\mathid{e}_{2}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}{\Gamma{}~\vdash{}~\mathkw{let}~\mathid{x}~=~\mathid{e}_{1}~\mathkw{in}~\mathid{e}_{2}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}{\brulename{\textsc{BIND}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk
\begin{mdtabular}{2}{\dimeval{(\linewidth)/2}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{v}~\xcolon{}~{\sigma}~~~~~\mathsf{k}~\not =~\mathsf{lab}~~~~~\alpha{}~\not\in \mathkw{ftv}(\Gamma{})}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\Lam{\alpha{}^\mathsf{k}}~\mathid{v}~\xcolon{}~\forall \alpha{}^\mathsf{k}.{\sigma}}{\brulename{\textsc{TABS}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}~\xcolon{}~\forall \alpha{}^\mathsf{k}.\sigma_{1}\midbar{}{\epsilon}~~~~~~\!\vdash_{\!\textsf{wf}}~{\sigma}~\xcolon{}~\mathsf{k}}{\Gamma{}~\vdash{}~\mathid{e}~{\sigma}~\xcolon{}~\sigma_{1}[\alpha{}{:\!=}{\sigma}]\midbar{}{\epsilon}}{\brulename{\textsc{TAPP}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{op}~\xcolon{}~\forall \overline{\alpha}.\tau_{1}~{\rightarrow}~\tau_{2}~\in \Sigma{}({\mathid{c}_\mathid{l}})\\\!\vdash_{\!\textsf{eq}}~(\tau_{1}[\overline{\alpha}{:\!=}{\overline\sigma}]\,~{\overline{\sigma'}})~{\equiv}~\sigma_{1}~\xcolon{}~*~~~~~~~~~~~~~~\!\vdash_{\!\textsf{eq}}~(\tau_{2}[\overline{\alpha}{:\!=}{\overline\sigma}]\,~{\overline{\sigma'}})~{\equiv}~\sigma_{2}~\xcolon{}~*}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathkw{perform}~\mathid{op}~\langle{}{\mathid{c}_\mathid{l}}\,~{\overline{\sigma'}}\midbar{}{\epsilon}\,\rangle{}~{\overline\sigma}~\xcolon{}~\sigma_{1}~{\rightarrow}~\langle{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}\,\rangle{}~\sigma_{2}}{\brulename{\textsc{PERFORM}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{ops}}~\mathid{h}~\xcolon{}~{\sigma}\midbar{}\mathid{l}\midbar{}{\epsilon}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathkw{handler}^{\epsilon}~\mathid{h}~\xcolon{}~(()~{\rightarrow}~\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}~{\sigma})~{\rightarrow}~{\epsilon}~{\sigma}}{\brulename{\textsc{HANDLER}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\{\mathid{op}_\mathid{i}~\xcolon{}~\forall \overline{\alpha}_\mathid{i}.{\tau}_{\mathid{i}}^{\mathid{in}}~{\rightarrow}~{\tau}_{\mathid{i}}^{\mathid{out}}~\}_{\mathid{i}=1}^\mathid{n}~=~\Sigma{}({\mathid{c}_\mathid{l}})~~~~~~~\overline{\alpha}_\mathid{i}~\not\cap \mathkw{ftv}({\epsilon},~{\overline\sigma},~{\overline{\sigma'}})\\\!\vdash_{\!\textsf{eq}}~{\tau}_\mathid{i}^{\mathid{in}}~{\overline{\sigma'}}~{\equiv}~{\sigma}_\mathid{i}^{\mathid{in}}~\xcolon{}~*~~~~~~~\!\vdash_{\!\textsf{eq}}~{\tau}_\mathid{i}^{\mathid{out}}~{\overline{\sigma'}}~{\equiv}~{\sigma}_\mathid{i}^{\mathid{out}}~\xcolon{}~*\\\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{f}_\mathid{i}~\xcolon{}~\forall \overline{\alpha{}_\mathid{i}}.{\sigma}_{\mathid{i}}^{\mathid{in}}~{\rightarrow}~{\epsilon}~(({\sigma}_{\mathid{i}}^{\mathid{out}}~{\rightarrow}~{\epsilon}~{\sigma})~{\rightarrow}~{\epsilon}~{\sigma})}{\Gamma{}~\!\vdash_{\!\textsf{ops}}~\{\mathid{op}_1~{\rightarrow}~\mathid{f}_1,{\dots},\mathid{op}_\mathid{n}~{\rightarrow}~\mathid{f}_\mathid{n}\}~\xcolon{}~{\sigma}\midbar{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}}{\brulename{\textsc{OPS}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk
\begin{mdtabular}{2}{\dimeval{(\linewidth-\dimwidth{0.45})/1}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.45}}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{f}~\xcolon{}~({\sigma}~{\rightarrow}~{\epsilon}'~{\sigma}')~{\rightarrow}~{\epsilon}'~{\sigma}'}{\Gamma{}~\vdash{}~\mathkw{yield}~\mathid{m}~\mathid{f}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}{\brulename{\textsc{YIELD}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}'~\sigma_{2}~~~~~~{\epsilon}'~\prefix {\epsilon}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathkw{open}~{\epsilon}~\mathid{v}~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}}{\brulename{\textsc{OPEN}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{ops}}~\mathid{h}~\xcolon{}~{\sigma}\midbar{}\mathid{l}\midbar{}{\epsilon}~~~~~~~~~\Gamma{}~\vdash{}~\mathid{e}~\xcolon{}~{\sigma}\midbar{}\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}}{\Gamma{}~\vdash{}~\mathkw{prompt}~\mathid{m}~\mathid{h}~\mathid{e}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}{\brulename{\textsc{PROMPT}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}~\xcolon{}~{\sigma}\midbar{}{\epsilon}'~~~~~~~{\epsilon}'~\prefix {\epsilon}}{\Gamma{}~\vdash{}~\mathkw{restrict}~{\epsilon}'~\mathid{e}~\xcolon{}~{\sigma}\midbar{}{\epsilon}}{\brulename{\textsc{RESTRICT}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\noindent Closed Prefix: $\mathpre{\langle{}\mathid{l}_1,{\dots},\mathid{l}_\mathid{n}\,\rangle{}~\prefix \langle{}\mathid{l}_1,{\dots},\mathid{l}_\mathid{n}\midbar{}{\epsilon}\,\rangle{}~\quad (\mathid{n}~\geq 0)}$%mdk

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{4}.}~\mdcaptiontext{Typing Rules of System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-static}{4}%mdk
%mdk
\end{figure}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{polythrow}~\xcolon{}~\forall \beta{}.(\lambda \alpha{}.\alpha{})~{\rightarrow}~(\lambda \alpha{}.\beta{})~\in \Sigma{}(\mathid{polyexn})\\\!\vdash_{\!\textsf{eq}}~(\lambda \alpha{}.\alpha{})[\beta{}{:\!=}\mathid{int}]~\mathid{string}~{\equiv}~\mathid{string}~~~~~~~~\!\vdash_{\!\textsf{eq}}~(\lambda \alpha{}.\beta{})[\beta{}{:\!=}\mathid{int}]~\mathid{string}~{\equiv}~\mathid{int}}{\mathid{x}~\xcolon{}~\mathid{string}~\!\vdash_{\!\textsf{val}}~\mathkw{perform}~\mathid{polythrow}~\total{}~\mathid{int}~\xcolon{}~\mathid{string}~{\rightarrow}~\langle{}\mathid{polyexn}~\mathid{string}\,\rangle{}~\mathid{int}}{\brulename{\textsc{}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\noindent The $\mathpre{\brulename{{HANDLER}}}$ rule is defined for handler expressions.
A handler takes a computation of type $\mathpre{(()~{\rightarrow}~\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}~{\sigma})}$ and handles the effect $\mathpre{\mathid{l}}$.
Hence, the effect row of the entire function type is $\mathpre{{\epsilon}}$, not $\mathpre{\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}}$.%mdk

The $\mathpre{\brulename{{OPS}}}$ rule determines the effect labels $\mathpre{{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}}$, which indicate the handled effect.
Each operation clause $\mathpre{\mathid{f}_\mathid{i}}$ takes an operation argument of type $\mathpre{{\sigma}_{\mathid{i}}^{\mathid{in}}}$ and
a resumption of type $\mathpre{{\sigma}_{\mathid{i}}^{\mathid{out}}~{\rightarrow}~{\epsilon}~{\sigma}}$.
The result type ($\mathpre{{\sigma}}$) of the handler is the result type of all resumptions and operation clauses,
because handlers in System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$ are \emph{deep} ones.
The condition $\mathpre{\overline{\alpha}_\mathid{i}~\not\cap \mathkw{ftv}({\epsilon},{\sigma},~{\overline{\sigma'}})}$ avoids unexpected binding in the type of $\mathpre{\mathid{f}_\mathid{i}}$.
The arguments of effect constants $\mathpre{{\overline{\sigma'}}}$ are derived from the typing of each operation clause.
By combining them with the effect constant $\mathpre{{\mathid{c}_\mathid{l}}}$, we derive the effect label $\mathpre{{\mathid{c}_\mathid{l}}\,{\overline{\sigma'}}}$.%mdk

The $\mathpre{\brulename{{YIELD}}}$ rule requires careful reading.
Recall that $\mathpre{\mathid{f}}$ is a wrapped handler clause that will be applied to a resumption.
The result type of $\mathpre{\mathid{f}}$, which is the result type of the handler clause, must agree with the result type of the resumption.
Therefore the two $\mathpre{{\sigma}'}$ need to agree.
The two $\mathpre{{\sigma}}$ indicate that
the input type of $\mathpre{\mathid{f}}$, which is the type of the \textquotedblleft{}result\textquotedblright{} of the operation call, must agree with the type of the yield expression.
Note that the effect type $\mathpre{{\epsilon}}$ of $\mathpre{\mathkw{yield}}$ is not related to the effect $\mathpre{{\epsilon}'}$ of the operation clause,
as the evaluation contexts of $\mathpre{\mathkw{yield}}$ and $\mathpre{\mathkw{prompt}}$ (in which $\mathpre{\mathid{f}}$ will be evaluated) are different in general.%mdk

The $\mathpre{\brulename{{PROMPT}}}$ rule extends the contextual effect $\mathpre{{\epsilon}}$ with the effect label $\mathpre{\mathid{l}}$ to type check sub-expression $\mathpre{\mathid{e}}$.
The result type of $\mathpre{\mathid{e}}$ and that of handler clauses $\mathpre{\mathid{h}}$ need to agree, and it becomes the type of the entire prompt expression.%mdk

The $\mathpre{\brulename{{OPEN}}}$ rule opens (make bigger) the effect type to the given effect $\mathpre{{\epsilon}}$.
The original effect type $\mathpre{{\epsilon}'}$ must be a \emph{closed prefix} of the resulting effect type $\mathpre{{\epsilon}}$.
An effect row $\mathpre{\epsilon_{1}}$ is a closed prefix of $\mathpre{\epsilon_{2}}$
if and only if $\mathpre{\epsilon_{1}}$ consists of labels in a prefix of $\mathpre{\epsilon_{2}}$ and ends in $\mathpre{\total{}}$.
We discuss the definition of the closed prefix relation in the next section.
The $\mathpre{\brulename{{RESTRICT}}}$ rule is similar to $\mathpre{\brulename{{OPEN}}}$ and allows
expression $\mathpre{\mathid{e}}$ to be typed under a closed prefix $\mathpre{{\epsilon}'}$.%mdk

\subsection{3.4.\hspace*{0.5em}Effect Rows and Closed Prefix Relation}\mdlabel{sec-prefix}{3.4}%mdk%mdk

\noindent In this section, we discuss how the type system exploits effect rows
to perform type checking against effect handlers and discuss
requirement for $\mathpre{\mathkw{open}}$ and $\mathpre{\mathkw{restrict}}$ to entail type safety.%mdk

Recall the typing rule $\mathpre{\brulename{{PERFORM}}}$ for operation calls.
The conclusion of the rule has an effect row $\mathpre{\langle{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}\,\rangle{}}$,
which tells us that evaluation of the operation call needs to access a handler of effect label $\mathpre{{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}}$.
The accessibility of the required handler is guaranteed by the row equivalence rules defined in Figure~\mdref{fig-row}{\mdcaptionlabel{2}}.
For instance, among the two examples below, the first one is correctly rejected due to the inapplicability of $\mathpre{\brulename{{EQ-SWAP}}}$,
and the second one is accepted as desired.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{handler}~\mathid{h}^{\mathid{polyexn}~\mathid{int}}~(\mathkw{handler}~\mathid{h}^{\mathid{polyexn}~\mathid{string}}~(\lambda\_.~\mathid{throw}\,~1))\\
\mathkw{handler}~\mathid{h}^{\mathid{polyexn}~\mathid{int}}~(\mathkw{handler}~\mathid{h}^{\mathid{polyexn}~\mathid{string}}~(\lambda\_.~\mathid{throw}~"\mathid{hello}"))
\end{mdmathpre}%mdk
\]%mdk
\noindent We design the closed prefix relation so that $\mathpre{\mathkw{restrict}}$
does not increase handlers accessible from the sub-expressions.

This is stated as the following property.

\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
\noindent\textbf{Proposition~1.} \mdbr
If $\mathpre{{\epsilon}.\mathid{l}}$ is defined and $\mathpre{{\epsilon}~\prefix {\epsilon}'}$, then $\mathpre{{\epsilon}'.\mathid{l}}$ is also defined and $\mathpre{{\epsilon}.\mathid{l}~=~{\epsilon}'.\mathid{l}}$.%mdk%mdk
\end{mdbmarginx}%mdk

\noindent It is obvious that the closed prefix relation satisfies this property, but what about other candidates?
Initially, we considered an \emph{open prefix} relation defined as follows.\mdfootnote{2}{\noindent In the Koka-related literature~[\mdcite{leijen2017type}{9}, \mdcite{xie2020effect}{19}, \mdcite{xie:gep}{20}], an effect row is called closed when it ends with $\mathpre{\total{}}$, and open when its tail ends with a type variable. We adopt the naming convention of the above literature.%mdk
\mdlabel{fn-fnopen}{2}%mdk%mdk
}%mdk
\noindent\[\begin{mdmathpre}%mdk
\langle{}\mathid{l}_{1},{\dots},\mathid{l}_\mathid{k}\midbar{}\mu{}\,\rangle{}~\prefix_?~\langle{}\mathid{l}_{1},{\dots},\mathid{l}_\mathid{k},\mathid{l}_{\mathid{k}+1},{\dots},\mathid{l}_\mathid{n}\midbar{}\mu{}\,\rangle{}
\end{mdmathpre}%mdk
\]%mdk
\noindent Here, $\mathpre{\mu{}}$ is a type variable of kind $\mathpre{\mathsf{eff}}$.
The open prefix relation leads to loss of type safety, as shown by the following example.
\noindent\[\begin{mdmathpre}%mdk
(\Lambda \mu{}.\lambda^{\langle{}\mathid{polyexn}~\mathid{int}\midbar{}\mu{}\,\rangle{}}~\mathid{f}\xcolon{}(){\rightarrow}\mu{}~().~\mathkw{restrict}~\mu{}~(\mathid{f}~()))\\
\mdmathindent{2}\langle{}\mathid{polyexn}~\mathid{string}\,\rangle{}~\lambda^{\langle{}\mathid{polyexn}~\mathid{string}\,\rangle{}}\_.\mathid{polythrow}~"\mathid{blame}!"
\end{mdmathpre}%mdk
\]%mdk
\noindent Here, the example would be accepted with an open prefix relation
because $\mathpre{\mu{}~\prefix_?~\langle{}\mathid{polyexn}~\mathid{int}\midbar{}\mu{}\,\rangle{}}$ holds.
However, the effect annotation $\mathpre{\langle{}\mathid{polyexn}~\mathid{int}\midbar{}\mu{}\,\rangle{}}$ indicates that the innermost $\mathpre{\mathid{polyexn}}$ handler expects $\mathpre{\mathid{polyexn}~\mathid{int}}$,
while $\mathpre{\mathid{polythrow}}$ raises a string value, causing a type mismatch at runtime! Fortunately,
using the closed prefix relation will reject the example and preserve
soundness.


\section{4.\hspace*{0.5em}Open Floating}\mdlabel{sec-floating}{4}%mdk%mdk

\noindent In this section, we present open floating, a transformation algorithm defined on System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$.
We first provide the design of open floating intuitively (Section~\mdref{sec-intu}{4.1}).
We next describe how to implement the idea with defining auxiliary definitions (Section~\mdref{sec-aux}{4.2}).
We then detail the definition of open floating (Section~\mdref{sec-alg}{4.3}).
Lastly, we show an example of the transformation (Section~\mdref{sec-float-ex}{4.4}).%mdk

If the reader is interested in the overall idea of the algorithm instead of the details,
the reader may skip the formal sections (Sections~\mdref{sec-aux}{4.2} and~\mdref{sec-alg}{4.3}).%mdk

\subsection{4.1.\hspace*{0.5em}Design of Algorithm}\mdlabel{sec-intu}{4.1}%mdk%mdk

\noindent Open floating is designed under the strategy \emph{assign minimum effect for each sub-expression}.
The first half of this section motivates the strategy and the latter half explains a post-process of open floating.
In order to reduce open constructs, we first float up open constructs and then collapse redundant ones.
We call the first phase open floating, and the second phase the post-process.%mdk

The aim of open floating is to fuse multiple open constructs into one.
We saw an example in Section~\mdref{sec-intro}{1} that shows open floating fuses two $\mathpre{\mathkw{open}}$s into one $\mathpre{\mathkw{restrict}}$.
There is one constraint that must be satisfied by open floating: the transformed program is well-typed.
The simplicity of the constraint is due to the formalization of $\mathpre{\mathkw{open}}$ and $\mathpre{\mathkw{restrict}}$ we saw in Section~\mdref{sec-fpwo}{3}.
Now the question is: how can we reduce open constructs while satisfying this constraint?
Our answer is to \emph{assign minimum effect for each sub-expression}.%mdk

Before open floating, open constructs are used to assign the maximum effect type to each expression.
Effect adjustments are never inserted in the middle of ASTs.
Instead, every expression is assigned a big effect, and if a function call requires effect adjustment, an open construct is inserted to the function call.
If adjacent sub-expressions perform the same effect adjustment,
we can avoid adjustments at function calls by making the adjustment surround those sub-expressions,
which makes the effect types of sub-expressions \emph{smaller}.
Based on this idea, in open floating, we assign the minimum effect type to each sub-expression.%mdk


Unfortunately, the above strategy is naive in that it may insert redundant $\mathpre{\mathkw{restrict}}$ in a corner case.
For instance, the following transformation increases the number of open/restrict constructs from three to four.
The problem is the $\mathpre{\mathkw{restrict}}$ in line 3 of the transformed program. We eliminate it by the post-process.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{f}~\xcolon{}~()~{\rightarrow}~\langle{}\mathid{l}_{1}\,\rangle{}~(),\quad \mathid{g}~\xcolon{}~()~{\rightarrow}~\langle{}\mathid{l}_{2}\,\rangle{}~(),\quad \mathid{h}~\xcolon{}~()~{\rightarrow}~\langle{}\mathid{l}_{3}\,\rangle{}~()
\end{mdmathpre}%mdk
\]%mdk
\begin{mdtabular}{3}{\dimeval{(\linewidth-\dimwidth{0.48}-\dimwidth{0.10})/1}}{0pt}%mdk
\begin{tabular}{lll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.48}}%mdk
\noindent\[\begin{mdmathpre}%mdk
\lambda^{\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}\_.\\
\mathkw{let}~\mathid{x}~=~\mathkw{open}~\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{f}~()~\mathkw{in}\\
\mathkw{let}~\mathid{y}~=~\mathkw{open}~\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{g}~()~\mathkw{in}\\
\mathkw{open}~\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{h}~()
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.10}}%mdk
\noindent$\mathpre{{\;\rightsquigarrow}\;}$%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\lambda^{\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}\_.\\
\mathkw{let}~\mathid{x}~=~\mathkw{restrict}~\langle{}\mathid{l}_{1}\,\rangle{}~\mathid{f}~()~\mathkw{in}\\
\mathkw{restrict}~\langle{}\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~(\\
\mdmathindent{2}\mathkw{let}~\mathid{y}~=~\mathkw{restrict}~\langle{}\mathid{l}_{2}\,\rangle{}~\mathid{g}~()~\mathkw{in}\\
\mdmathindent{2}\mathkw{restrict}~\langle{}\mathid{l}_{3}\,\rangle{}~\mathid{h}~())
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\noindent It is not hard to see the validity of this removal: the necessary effect adjustment is performed by the $\mathpre{\mathkw{restrict}}$s on lines 4 and 5.
In general, a $\mathpre{\mathkw{restrict}}$ is redundant if removing it does not force the sub-expressions to use additional $\mathpre{\mathkw{open}}$ or $\mathpre{\mathkw{restrict}}$.
We can detect such $\mathpre{\mathkw{restrict}}$s by checking the sub-expressions of restrict-expressions.%mdk





\subsection{4.2.\hspace*{0.5em}Organization of Definition}\mdlabel{sec-aux}{4.2}%mdk%mdk

\noindent The algorithm consists of three kinds of rules, taking care of expressions, values, and operation clauses.%mdk

\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

\item$\mathpre{\Gamma{}~\vdash{}~\mathid{e}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~{\sigma}\midbar{}\varphi}$%mdk

\item$\mathpre{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~{\;\rightsquigarrow}\;~\mathid{v}'~\xcolon{}~{\sigma}}$%mdk

\item$\mathpre{\Gamma{}~\!\vdash_{\!\textsf{ops}}~\mathid{h}~{\;\rightsquigarrow}\;~\mathid{h}'~\xcolon{}~{\sigma}\midbar{}\mathid{l}\midbar{}{\epsilon}}$%mdk
%mdk
\end{itemize}%mdk

\noindent In this study, proper programs are well-typed and \emph{internal-safe} expressions.%mdk

\begin{mdbmarginx}{1ex}{0pt}{1ex}{0pt}%mdk
\noindent\textbf{Definition~1.} ({\itshape Internal-free expression, Internal-safe expression})\mdbr
An expression is \emph{internal-safe} if it is
(1) internal-free (contains no prompt or yield expressions) or
(2) reduced from an internal-safe expression.%mdk
\mdlabel{internal}{1}%mdk%mdk
\end{mdbmarginx}%mdk

\noindent Open floating takes a proper program fragment and outputs
proper program fragment with an \emph{effect requirement} $\mathpre{\varphi}$ (defined in Section~\mdref{sec-alg}{4.3}).
To define open floating, we represent the \textquotedblleft{}minimum effect\textquotedblright{} of an expression as an effect requirement.
It is an extension of effect row types with the bottom (least) value $\mathpre{\varnothing{}}$.
Open floating calculates the effect type of the transformed expression in a bottom-up way with effect requirements.
If the effect requirement of the expression is an effect row type,
then the expression is assigned that effect type as the output of the algorithm.
If the effect requirement of the expression is the bottom value,
the expression is assigned an appropriate effect type determined later by the surrounding context.%mdk


When we assign effect types to expressions, we need to maintain well-typedness of expressions.
The auxiliary functions defined in Figure~\mdref{fig-effrq}{\mdcaptionlabel{5}} help us do so.
For instance, in the case of a function application, the effect types of
the operation, the operand, and the body of operation must be the same.
To ensure this, we first calculate the effect requirement of the whole function application using the $\mathpre{\mathid{sup}}$ function,
and then make the effect types consistent by inserting open constructs using $\mathpre{\mathid{open}'}$ and $\mathpre{\mathid{restrict}'}$.
Note that $\mathpre{\mathid{open}'}$ may produce let bindings to ensure that the function is syntactically a value, which is required by the syntax rule of $\mathpre{\mathkw{open}}$.%mdk


\begin{figure}[t]%mdk
\begin{mdflushleft}%mdk

\begin{mdbmargintb}{}{-1.25em}%mdk
\noindent Effect Requirement: $\mathpre{\varphi}$::=$\mathpre{\varnothing{}\midbar{}{\epsilon}}$, with an order defined as:%mdk
\end{mdbmargintb}%mdk
\begin{mdtabular}{3}{\dimeval{(\linewidth)/3}}{0pt}%mdk
\begin{tabular}{lll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{}{\varnothing{}~{\sqsubseteq}~\varphi}{\brulename{\textsc{BOTTOM}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{}{\varphi {\sqsubseteq}~\varphi}{\brulename{\textsc{REFL}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\epsilon_{1}~\prefix \epsilon_{2}}{\epsilon_{1}~{\sqsubseteq}~\epsilon_{2}}{\brulename{\textsc{PREFIX}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}
\noindent\[\begin{mdmathpre}%mdk
\mathid{sup}~\xcolon{}~\mathid{Requirement}~{\longrightarrow}~2^{\mathid{Requirement}}~{\longrightarrow}~\mathid{Requirement}\\
\mathid{sup}_{{\epsilon}}~\{\varphi_\mathid{i}\}_\mathid{i}~=~\mathkw{min}~\{~\varphi \mid \varphi_\mathid{i}~{\sqsubseteq}~\varphi {\sqsubseteq}~{\epsilon}~\}
\end{mdmathpre}%mdk
\]%mdk
\begin{mdbmargintb}{}{-1.25em}%mdk
\noindent Smart open and restrict:%mdk
\end{mdbmargintb}\begin{mdtabular}{2}{\dimeval{(\linewidth)/2}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{padding-left=-1em,width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{open}'~\varphi \,\varphi'~\mathid{e}~~~&=~\mathid{e}~~~~~~~~~~~~~&(\mathid{if}~\varphi {\,\cong\,}~\varphi')\\
\mathid{open}'~\varnothing{}~\,\varphi'~\mathid{e}~~~&=~\mathid{e}~~~~~~~~~~~~~&\\
\mathid{open}'~{\epsilon}~\,{\epsilon}'~\mathid{e}~&=~&\\
\mdmathindent{2}\mathkw{let}~\mathid{x}~=~\mathid{e}~\mathkw{in}~&\mathkw{open}~{\epsilon}'~\mathid{x}~&(\mathid{if}~{\epsilon}~\prefix {\epsilon}')\\
\mathid{open}'~\varphi \,\varphi'~\mathid{e}~~~&=~\mathid{undefined}~~~~~&(\mathid{otherwise})
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{restrict}'~\varphi\,~\varphi'~\mathid{e}~~~&=~\mathid{e}~~~~~~~~~~~~~~~~&(\mathid{if}~\varphi {\,\cong\,}~\varphi')\\
\mathid{restrict}'~\varnothing{}\,~\varphi'~\mathid{e}~~~&=~\mathid{e}~~~~~~~~~~~~~~~~&\\
\mathid{restrict}'~{\epsilon}\,~{\epsilon}'~\mathid{e}~&=~\mathkw{restrict}~{\epsilon}~\mathid{e}~~&(\mathid{if}~{\epsilon}~\prefix {\epsilon}')\\
\mathid{restrict}'~\varphi\,~\varphi'~\mathid{e}~~~&=~\mathid{undefined}~~~~~~~~&(\mathid{otherwise})
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{5}.}~\mdcaptiontext{Effect Requirement and Auxiliary Definitions}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-effrq}{5}%mdk
%mdk
\end{figure}%mdk

\subsection{4.3.\hspace*{0.5em}The Definition}\mdlabel{sec-alg}{4.3}%mdk%mdk

\begin{figure}[h!]%mdk
\begin{mdflushleft}%mdk
\begin{mdbmargintb}{}{-1em}%mdk
\begin{mdblock}{padding=0.5ex,border-width=\dimpx{1},border-color=black,border-style=solid}%mdk
\noindent\[\begin{mdmathpre}%mdk
\Gamma{}~\vdash{}~\mathid{e}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~{\sigma}'\midbar{}\gray{\varphi}~%\\
\quad\quad \Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~{\;\rightsquigarrow}\;~\mathid{v}'~\xcolon{}~{\sigma}%\\
\quad\quad \Gamma{}~\!\vdash_{\!\textsf{ops}}~\mathid{h}~{\;\rightsquigarrow}\;~\mathid{h}'~\xcolon{}~{\sigma}\midbar{}\mathid{l}\midbar{}{\epsilon}%
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdbmargintb}\begin{mdtabular}{2}{\dimeval{(\linewidth-\dimwidth{0.50})/1}}{0pt}%mdk
\begin{tabular}{ll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.50}}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{x}~\xcolon{}~{\sigma}~~\in \Gamma{}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{x}~{\;\rightsquigarrow}\;~\mathid{x}~\xcolon{}~{\sigma}}{\brulename{\textsc{Var}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{v}~{\;\rightsquigarrow}\;~\mathid{v}'~\xcolon{}~{\sigma}}{\Gamma{}~\vdash{}~\mathid{v}~{\;\rightsquigarrow}\;~\mathid{v}'~\xcolon{}~{\sigma}\midbar{}\varnothing{}}{\brulename{\textsc{Val}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~\forall \alpha{}^\mathid{k}.\sigma_{1}\midbar{}\varphi}{\Gamma{}~\vdash{}~\mathid{e}~[{\sigma}']\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~[{\sigma}']~\xcolon{}~{\sigma}[\alpha{}{:\!=}{\sigma}']\midbar{}\varphi}{\brulename{\textsc{TApp}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{},~\alpha{}^\mathid{k}~\!\vdash_{\!\textsf{val}}~\mathid{v}~{\;\rightsquigarrow}\;~\mathid{v}'~\xcolon{}~{\sigma}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\Lambda \alpha{}^\mathid{k}.\mathid{v}~{\;\rightsquigarrow}\;~\Lambda \alpha{}^\mathid{k}.\mathid{v}'~\xcolon{}~\forall \alpha{}.~{\sigma}}{\brulename{\textsc{TAbs}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}
%mdk-begin-texraw
\vspace{-2em}

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{},~\mathid{x}~\xcolon{}~\sigma_{1}~\vdash{}~\mathid{e}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~\sigma_{2}\midbar{}\varphi \quad \side{\varphi  {\sqsubseteq}~~{\epsilon}}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\lambda^{\epsilon}~\mathid{x}\xcolon{}\sigma_{1}.~\mathid{e}~~~{\;\rightsquigarrow}\;~\lambda^{\epsilon}~\mathid{x}\xcolon{}\sigma_{1}.~\mathid{restrict}'~\varphi\,~{\epsilon}~\mathid{e}'~~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}}{\brulename{\textsc{Lam}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk


\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}_{1}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}_{1}'~\xcolon{}~\sigma_{2}~{\rightarrow}~{\epsilon}_{\mathkw{body}}~{\sigma}\midbar{}\varphi_{1}~~\quad \Gamma{}~\vdash{}~\mathid{e}_{2}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}_{2}~\xcolon{}~\sigma_{2}\midbar{}\varphi_{2}\\{\epsilon}_\mathid{s}~=~\mathid{sup}_{{\epsilon}}~\{{\epsilon}_{\mathkw{body}},~\varphi_{1},~\varphi_{2}\}}{\Gamma{}~\vdash{}~\mathid{e}_{1}~\mathid{e}_{2}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~(\mathid{open}'~{\epsilon}_{\mathkw{body}}~{\epsilon}_\mathid{s}~(\mathid{restrict}'~\varphi_{1}~{\epsilon}_\mathid{s}~(\mathid{e}_{1}'))~)~(\mathid{restrict}'~\varphi_{2}~{\epsilon}_\mathid{s}~\mathid{e}_{2}')~\xcolon{}~{\sigma}\midbar{}{\epsilon}_\mathid{s}}{\brulename{\textsc{App}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk


\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}_{1}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}_{1}'~\xcolon{}~\sigma_{1}\midbar{}\varphi_{1}~~\quad \Gamma{}~\vdash{}~\mathid{e}_{2}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}_{2}'~\xcolon{}~\sigma_{2}\midbar{}\varphi_{2}~~\quad  \varphi =~\mathid{sup}_{{\epsilon}}~\{\varphi_{1},~\varphi_{2}\}}{\Gamma{}~\vdash{}~\mathkw{let}~\mathid{x}~=~\mathid{e}_{1}~\mathkw{in}~\mathid{e}_{2}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathkw{let}~\mathid{x}~=~\mathid{restrict}'~\varphi_{1}~\varphi\,~\mathid{e}_{1}'~\mathkw{in}~\mathid{restrict}'~\varphi_{2}~\varphi\,~\mathid{e}_{2}'~\xcolon{}~\sigma_{2}\midbar{}\varphi}{\brulename{\textsc{Bind}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\mathid{op}~\xcolon{}~\forall \overline{\alpha}.\tau_{1}~{\rightarrow}~\tau_{2}~\in \Sigma{}({\mathid{c}_\mathid{l}})~~~~~\quad \overline{\alpha}~\not\cap \mathkw{ftv}(\Gamma{})\\\!\vdash_{\!\textsf{eq}}~(\tau_{1}[\overline{\alpha}{:\!=}{\overline\sigma}]\,~{\overline{\sigma'}})~{\equiv}~\sigma_{1}~\xcolon{}~*~~~~~~\!\vdash_{\!\textsf{eq}}~(\tau_{2}[\overline{\alpha}{:\!=}{\overline\sigma}]\,~{\overline{\sigma'}})~{\equiv}~\sigma_{2}~\xcolon{}~*}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathkw{perform}~\mathid{op}~\langle{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}\,\rangle{}~{\overline\sigma}~{\;\rightsquigarrow}\;~\mathkw{perform}~\mathid{op}~\langle{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}\,\rangle{}~{\overline\sigma}~~\xcolon{}~\sigma_{1}{\rightarrow}~\langle{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}\,\rangle{}~\sigma_{2}}{\brulename{\textsc{Perform}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\!\vdash_{\!\textsf{ops}}~\mathid{h}~{\;\rightsquigarrow}\;~\mathid{h}'~\xcolon{}~{\sigma}\midbar{}\mathid{l}\midbar{}{\epsilon}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathkw{handler}^{\epsilon}~\mathid{h}~{\;\rightsquigarrow}\;~\mathkw{handler}^{\epsilon}~\mathid{h}'~\xcolon{}~(()~{\rightarrow}~\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}~{\sigma})~{\rightarrow}~{\epsilon}~{\sigma}}{\brulename{\textsc{Handler}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\{\mathid{op}_\mathid{i}~\xcolon{}~\forall \overline{\alpha}_\mathid{i}.{\tau}_{\mathid{i}}^{\mathid{in}}~{\rightarrow}~{\tau}_{\mathid{i}}^{\mathid{out}}~\}_{\mathid{i}=1}^\mathid{n}~=~\Sigma{}({\mathid{c}_\mathid{l}})~~~~~~~\overline{\alpha}_\mathid{i}~\not\cap \mathkw{ftv}({\epsilon},~{\overline\sigma},~{\overline{\sigma'}})\\\!\vdash_{\!\textsf{eq}}~{\tau}_\mathid{i}^{\mathid{in}}~{\overline{\sigma'}}~{\equiv}~{\sigma}_\mathid{i}^{\mathid{in}}~\xcolon{}~*~~~~~~~~~~~~\!\vdash_{\!\textsf{eq}}~{\tau}_\mathid{i}^{\mathid{out}}~{\overline{\sigma'}}~{\equiv}~{\sigma}_\mathid{i}^{\mathid{out}}~\xcolon{}~*\\\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathid{f}_\mathid{i}~{\;\rightsquigarrow}\;~\mathid{f}_\mathid{i}'~\xcolon{}~\forall \overline{\alpha{}_\mathid{i}}.{\sigma}_{\mathid{i}}^{\mathid{in}}~{\rightarrow}~{\epsilon}~(({\sigma}_{\mathid{i}}^{\mathid{out}}~{\rightarrow}~{\epsilon}~{\sigma})~{\rightarrow}~{\epsilon}~{\sigma})}{\Gamma{}~\!\vdash_{\!\textsf{ops}}~\{\mathid{op}_1~{\rightarrow}~\mathid{f}_1,{\dots},\mathid{op}_\mathid{n}~{\rightarrow}~\mathid{f}_\mathid{n}\}~{\;\rightsquigarrow}\;~\{\mathid{op}_1~{\rightarrow}~\mathid{f}_1',{\dots},~\mathid{op}_\mathid{n}~{\rightarrow}~\mathid{f}_\mathid{n}'\}~\xcolon{}~{\sigma}\midbar{}{\mathid{c}_\mathid{l}}~{\overline{\sigma'}}\midbar{}{\epsilon}}{\brulename{\textsc{Ops}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{v}~\mathid{e}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~{\sigma}\midbar{}\varphi    \quad\side{\varphi {\sqsubseteq}~{\epsilon}}}{\Gamma{}~\vdash{}~(\mathkw{open}~{\epsilon}~\mathid{v})~\mathid{e}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~{\sigma}\midbar{}\varphi}{\brulename{\textsc{Open-App}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{v}~{\;\rightsquigarrow}\;~\mathid{v}'~\xcolon{}~\sigma_{1}'~{\rightarrow}~{\epsilon}'~\sigma_{2}'~~~~~~~~~\side{{\epsilon}'~\prefix {\epsilon}}}{\Gamma{}~\!\vdash_{\!\textsf{val}}~\mathkw{open}~{\epsilon}~\mathid{v}~{\;\rightsquigarrow}\;~\mathkw{open}~{\epsilon}~\mathid{v}'~\xcolon{}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}}{\brulename{\textsc{Open-Preserve}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\Gamma{}~\vdash{}~\mathid{e}\midbar{}\epsilon_{1}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~{\sigma}\midbar{}\varphi}{\Gamma{}~\vdash{}~\mathkw{restrict}~\epsilon_{1}~\mathid{e}\midbar{}{\epsilon}~{\;\rightsquigarrow}\;~\mathid{e}'~\xcolon{}~{\sigma}\midbar{}\varphi}{\brulename{\textsc{Restrict}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{6}.}~\mdcaptiontext{Open Floating Algorithm}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-floating}{6}%mdk
%mdk
\end{figure}%mdk

\noindent We define the open floating algorithm in Figure~\mdref{fig-floating}{\mdcaptionlabel{6}} following the idea described in the previous section.
The $\mathpre{\side{\text{light propositions}}}$ are invariants,
not side conditions; we write them to clarify the intention of the algorithm design.
The transformation is syntax directed, except for applications ($\mathpre{\mathid{e}~\mathid{e}}$),
in which case both $\mathpre{\brulename{{Open-App}}}$ and $\mathpre{\brulename{{App}}}$ rules may apply.%mdk

Rule $\mathpre{\brulename{{Var}}}$ simply returns the variable with its type.
Rule $\mathpre{\brulename{{Lam}}}$ recursively applies the algorithm to the body $\mathpre{\mathid{e}}$.
We do not simply return $\mathpre{\lambda^\varphi \mathid{x}\xcolon{}\sigma_{1}.\mathid{e}'}$
but return $\mathpre{\lambda^{\epsilon}~\mathid{restrict}'~\varphi\,~{\epsilon}~\mathid{e}'}$ in order
to preserve the type of the lambda abstraction.
Rule $\mathpre{\brulename{{Val}}}$ assigns a null requirement $\mathpre{\varnothing{}}$ to value.
Rule $\mathpre{\brulename{{App}}}$ treats three effect requirements: the requirements of the two sub-expressions ($\mathpre{\varphi_{1}}$ and $\mathpre{\varphi_{2}}$) and the effect type of the function body.
The rule uses the supremum of these requirements for the result.
Rule $\mathpre{\brulename{{Bind}}}$ also takes the supremum of the two effect rows.
Rules $\mathpre{\brulename{{TAbs}}}$, $\mathpre{\brulename{{TApp}}}$, $\mathpre{\brulename{{Perform}}}$, $\mathpre{\brulename{{Handler}}}$, and $\mathpre{\brulename{{Ops}}}$ simply recursively call the algorithm and propagate the results.%mdk

Rule $\mathpre{\brulename{{Open-App}}}$ processes application of an opened function.
It removes $\mathpre{\mathkw{open}}$ and may assign a smaller effect to the expression. This rule conflicts with the $\mathpre{\brulename{{App}}}$ rule,
hence we give priority to $\mathpre{\brulename{{Open-App}}}$.
Rule $\mathpre{\brulename{{Open-Preserve}}}$ recursively calls the algorithm while keeping $\mathpre{\mathkw{open}}$.
This rule is required for function arguments, for instance. Let us consider the following example.%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathid{safemap}~\xcolon{}~\mathid{list}\langle{}\mathid{int}\,\rangle{}~{\rightarrow}~\total{}~(\mathid{int}~{\rightarrow}~\langle{}\mathid{exn}\,\rangle{}~\mathid{int})~{\rightarrow}~\total{}~\mathid{list}\langle{}\mathid{int}\,\rangle{}\\
\mathid{safemap}~[1,~2,~3,~4]~(\mathkw{open}~\langle{}\mathid{exn}\,\rangle{}~\mathid{addone})
\end{mdmathpre}%mdk
\]%mdk

\noindent The $\mathpre{\mathid{safemap}}$ function expects a function argument of $\mathpre{\mathid{int}~{\rightarrow}~\langle{}\mathid{exn}\,\rangle{}~\mathid{int}}$ and handles the exception effect.
If we want to pass a function of effect $\mathpre{\total{}}$ as the argument ($\mathpre{\mathid{addone}}$ in this case),
we need to open it to make the entire program type check.
The last rule $\mathpre{\brulename{{Restrict}}}$ ignores the existing $\mathpre{\mathkw{restrict}}$.

\subsection{4.4.\hspace*{0.5em}Example}\mdlabel{sec-float-ex}{4.4}%mdk%mdk

\noindent Recall from Section~\mdref{sec-intu}{4.1} that open floating assigns the minimum effect to each sub-expression.
Let us observe how this principle is implemented by the definition.
Assume we have the following bindings in the type environment,
where $\mathpre{\mathid{l}_{1}}$, $\mathpre{\mathid{l}_{2}}$, and $\mathpre{\mathid{l}_{3}}$ are distinct effect labels.%mdk
\noindent\[\begin{mdmathpre}%mdk
\Gamma{}~=~\mathid{f}~\xcolon{}~\mathid{int}~{\rightarrow}~\langle{}\mathid{l}_{1},\mathid{l}_{2}\,\rangle{}~\mathid{int},~\mathid{g}~\xcolon{}~\mathid{int}~{\rightarrow}~\langle{}\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{int}
\end{mdmathpre}%mdk
\]%mdk
\noindent Then, open floating performs the following transformation.
\begin{mdtabular}{3}{\dimeval{(\linewidth-\dimwidth{0.48}-\dimwidth{0.10})/1}}{0pt}%mdk
\begin{tabular}{lll}

\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.48}}%mdk
\noindent\[\begin{mdmathpre}%mdk
\lambda^{\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}\mathid{x}\xcolon{}\mathid{int}.\\
\mdmathindent{2}\mathkw{let}~\mathid{y}~=~(\mathkw{open}~\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{f})~\mathid{x}~\mathkw{in}\\
\mdmathindent{2}\mathkw{let}~\mathid{z}~=~(\mathkw{open}~\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{g})~\mathid{y}~\mathkw{in}\\
\mdmathindent{2}(\mathkw{open}~\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{g})~\mathid{z}
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimwidth{0.10}}%mdk
\noindent$\mathpre{\quad{\;\rightsquigarrow}\;\quad}$%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
&
\begin{mdcolumn}%mdk
\begin{mdblock}{width=\dimavailable}%mdk
\noindent\[\begin{mdmathpre}%mdk
\lambda^{\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}\mathid{x}\xcolon{}\mathid{int}.\\
\mdmathindent{2}\mathkw{let}~\mathid{y}~=~\mathkw{restrict}~\langle{}\mathid{l}_{1},\mathid{l}_{2}\,\rangle{}~\mathid{f}~\mathid{x}~\mathkw{in}\\
\mdmathindent{2}\mathkw{restrict}~\langle{}\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~(\\
\mdmathindent{4}\mathkw{let}~\mathid{z}~=~\mathid{g}~\mathid{y}~\mathkw{in}\\
\mdmathindent{4}\mathid{g}~\mathid{z})
\end{mdmathpre}%mdk
\]%mdk%mdk
\end{mdblock}%mdk
\end{mdcolumn}%mdk
\\
\end{tabular}\end{mdtabular}

\noindent First, rules such as $\mathpre{\brulename{{Abs}}}$ and $\mathpre{\brulename{{Bind}}}$ are applied to the lambda abstraction and let-expressions.
The function application $\mathpre{(\mathkw{open}~\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}~\mathid{g})~\mathid{z}}$ in the last line is processed by rule $\mathpre{\brulename{{Open-App}}}$;
it outputs expression $\mathpre{\mathid{g}~\mathid{z}}$ with effect requirement $\mathpre{\langle{}\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}$.
The let-expression in the second-last line is processed by rule $\mathpre{\brulename{{Bind}}}$; it outputs expression $\mathpre{\mathkw{let}~\mathid{z}~=~\mathid{g}~\mathid{y}~\mathkw{in}~\mathid{g}~\mathid{z}}$ with
effect requirement $\mathpre{\langle{}\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}$.
Notice that two $\mathpre{\mathkw{open}}$s in this let-expression are eliminated.
This is because the effect type of the original program is $\mathpre{\langle{}\mathid{l}_{1},\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}$, while the transformed one has effect type
$\mathpre{\langle{}\mathid{l}_{2},\mathid{l}_{3}\,\rangle{}}$, which agrees with the effect of function $\mathpre{\mathid{g}}$.%mdk

Focusing our attention on the top-most let-expression, we see that two $\mathpre{\mathkw{restrict}}$s are inserted.
The transformed definition of the let-expression is $\mathpre{\mathid{f}~\mathid{x}}$ with effect requirement $\mathpre{\langle{}\mathid{l}_{1},\mathid{l}_{2}\,\rangle{}}$.
The whole let-expression need to require the effect that \textquotedblleft{}satisfies\textquotedblright{} the requirements of both sub-expressions.
This invariant is maintained by the $\mathpre{\brulename{{Bind}}}$ rule, which calculates the overall requirement using the $\mathpre{\mathid{sup}}$ function and inserts $\mathpre{\mathkw{restrict}}$ using the $\mathpre{\mathid{restrict}'}$ function if needed.
Here, both the definition and the body require different effects than the entire let-expression, hence $\mathpre{\mathkw{restrict}}$s are inserted (the inner let-expression does not require $\mathpre{\mathkw{restrict}}$ as there is no gap).
Lastly, the $\mathpre{\brulename{{Abs}}}$ rule (which is the first rule applied to the program) outputs the overall result of the transformation.
Thus, open floating floats up open constructs by determining the effect type of each sub-expression in a bottom-up way.%mdk

\section{5.\hspace*{0.5em}Evaluation}\mdlabel{sec-bench}{5}%mdk%mdk

\noindent We implemented our open floating algorithm in the Koka compiler~[\mdcite{leijen:kokarepo}{11}] and
evaluated open floating with artificial programs.
The results show that, in the best case, open floating makes programs about 2.5 times faster, while
in some cases, it makes programs slower.
In this section, we summarize the experiments and discuss
what kind of programs are made faster by open floating.%mdk

\subsection{5.1.\hspace*{0.5em}Ideal Case}\mdlabel{sec-ideal-case}{5.1}%mdk%mdk


\begin{figure}[tbp]%mdk
\begin{mdflushleft}%mdk
\begin{mdpre}%mdk
{\def~{\nobreakspace{}}\begin{mdbpaddingx}{}{}{}{1em}%mdk
\noindent{\small{\mdcolor{navy}fun}~test-one()~{\mdcolor{teal}:}~{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}exn}{\mdcolor{teal},}{\mdcolor{teal}read}{\mdcolor{teal}\mdsub{1}}{\mdcolor{teal},}{\mdcolor{teal}read}{\mdcolor{teal}\mdsub{2}}{\mdcolor{teal}\ensuremath{\rangle}}~{\mdcolor{teal}int}~~\\
~~{\mdcolor{navy}val}~x~{\mdcolor{navy}=}~square({\mdcolor{purple}1})~+~...~+~square({\mdcolor{purple}1})~~{\mdcolor{darkgreen}//}{\mdcolor{darkgreen}~call~`square(1)`~20~times}\\
~~{\mdcolor{navy}val}~y~{\mdcolor{navy}=}~square-ask\mdsub{1}()\\
~~{\mdcolor{navy}val}~z~{\mdcolor{navy}=}~square-ask\mdsub{2}()\\
~~x~+~y~+~z\\
}%mdk
\end{mdbpaddingx}}%mdk
\end{mdpre}\begin{mdpre}%mdk
{\def~{\nobreakspace{}}\begin{mdbpaddingx}{}{}{}{1em}%mdk
\noindent{\small{\mdcolor{navy}noinline}~{\mdcolor{navy}fun}~square(~i~{\mdcolor{teal}:}~{\mdcolor{teal}int}~)~{\mdcolor{teal}:}~{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}exn}{\mdcolor{teal},}~{\mdcolor{teal}read}{\mdcolor{teal}\mdsub{1}}{\mdcolor{teal}\ensuremath{\rangle}}~{\mdcolor{teal}int}~~\\
~~{\mdcolor{navy}if}~{\mdcolor{purple}True}~{\mdcolor{navy}then}~i~*~i~{\mdcolor{navy}else}~throw({\mdcolor{maroon}"}{\mdcolor{maroon}impossible:~}{\mdcolor{maroon}"}~++~ask\mdsub{1}(){\mdcolor{navy}.}show)}%mdk
\end{mdbpaddingx}}%mdk
\end{mdpre}\begin{mdpre}%mdk
{\def~{\nobreakspace{}}\begin{mdbpaddingx}{}{}{}{1em}%mdk
\noindent{\small{\mdcolor{navy}noinline}~{\mdcolor{navy}fun}~square-ask\mdsub{1}()~{\mdcolor{teal}:}~{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}read}{\mdcolor{teal}\mdsub{1}}{\mdcolor{teal}\ensuremath{\rangle}}~{\mdcolor{teal}int}~~~\\
~~ask\mdsub{1}()~*~ask\mdsub{1}()}%mdk
\end{mdbpaddingx}}%mdk
\end{mdpre}\begin{mdpre}%mdk
{\def~{\nobreakspace{}}\begin{mdbpaddingx}{}{}{}{1em}%mdk
\noindent{\small{\mdcolor{navy}noinline}~{\mdcolor{navy}fun}~square-ask\mdsub{2}()~{\mdcolor{teal}:}~{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}read}{\mdcolor{teal}\mdsub{2}}{\mdcolor{teal}\ensuremath{\rangle}}~{\mdcolor{teal}int}~~~\\
~~ask\mdsub{2}()~*~ask\mdsub{2}()}%mdk
\end{mdbpaddingx}}%mdk
\end{mdpre}\begin{mdtabular}{4}{\dimeval{(\linewidth)/4}}{1ex}%mdk
\begin{tabular}{lrrr}\midrule
{\bfseries Open floating}&\multicolumn{1}{|r}{{\bfseries Exec. time (sec.)}}&{\bfseries Open call (static)}&{\bfseries Open call (dynamic)}\\

\midrule
Enabled&\multicolumn{1}{|r}{0.957}&3&30,000\\
Disabled&\multicolumn{1}{|r}{2.388}&22&220,000\\
\midrule
\end{tabular}\end{mdtabular}

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{7}.}~\mdcaptiontext{Benchmarking open floating (the ideal case)}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-bench}{7}%mdk
%mdk
\end{figure}%mdk

\noindent Figure~\mdref{fig-bench}{\mdcaptionlabel{7}} includes a fragment of a small benchmark 
with the execution times. The number of open calls is the sum of $\mathpre{\mathkw{open}}$ and $\mathpre{\mathkw{restrict}}$ expressions in the program.
As we can see, open floating is very effective here and
the enabling open floating improves performance by 2.5\ensuremath{\times}.
The execution times are averaged over 3 runs,
on an Intel Core i5 at 3Ghz with 8GiB memory running macOS 11.6.3,
with Koka v2.3.9 extended with open floating.
In the program, we use three kinds of effects: \mdcode{read\mdsub{1}}, \mdcode{read\mdsub{2}}, and \mdcode{exn}.
The function \mdcode{test-one} has the effect \mdcode{\ensuremath{\langle}read\mdsub{1},read\mdsub{2},exn\ensuremath{\rangle}}, while
the other functions use smaller effects.
In the body of \mdcode{test-one}, the Koka type inferencer inserts
the following $\mathpre{\mathkw{open}}$ calls around 
the \mdcode{square}, \mdcode{square-ask\mdsub{1}}, and \mdcode{square-ask\mdsub{2}} functions:%mdk
\noindent\[\begin{mdmathpre}%mdk
\mathkw{let}~\mathid{x}~=~\mathkw{open}(\mathid{square})(1)~+~{\dots}~+~\mathkw{open}(\mathid{square})(1)~~\quad (\text{call}~\mathkw{open}(\mathid{square})(1)~\text{20 times})\\
\mathkw{let}~\mathid{y}~=~\mathkw{open}(\mathid{squareask}_{1})()\\
\mathkw{let}~\mathid{z}~=~\mathkw{open}(\mathid{squareask}_{2})()\\
\mathid{x}~+~\mathid{y}~+~\mathid{z}
\end{mdmathpre}%mdk
\]%mdk
\noindent This program contains 22 $\mathpre{\mathkw{open}}$ calls initially and open floating reduces them to 3 $\mathpre{\mathkw{restrict}}$s as follows:
\noindent\[\begin{mdmathpre}%mdk
\mathkw{let}~\mathid{x}~=~\mathkw{restrict}(~\mathid{square}(1)~+~{\dots}~+~\mathid{square}(1)~)~~\quad (\text{call}~\mathid{square}(1)~\text{20 times})\\
\mathkw{let}~\mathid{y}~=~\mathkw{restrict}(\mathid{squareask}_{1}())\\
\mathkw{let}~\mathid{z}~=~\mathkw{restrict}(\mathid{squareask}_{2}())\\
\mathid{x}~+~\mathid{y}~+~\mathid{z}
\end{mdmathpre}%mdk
\]%mdk
\noindent Here all individual $\mathpre{\mathkw{open}}$ calls around each $\mathpre{\mathid{square}}$ invocation
are floated up to a single $\mathpre{\mathkw{restrict}}$, leading to the improved
performance.

\subsection{5.2.\hspace*{0.5em}Failure Case}\mdlabel{sec-failure}{5.2}%mdk%mdk

\begin{figure}[tbp]%mdk
\begin{mdflushleft}%mdk
\begin{mdtabular}{4}{\dimeval{(\linewidth)/4}}{1ex}%mdk
\begin{tabular}{lrrr}\midrule
{\bfseries Open floating}&\multicolumn{1}{|r}{{\bfseries Exec. time (sec.)}}&{\bfseries Open call (static)}&{\bfseries Open call (dynamic)}\\

\midrule
Enabled&\multicolumn{1}{|r}{0.500}&3&30,000\\
Disabled&\multicolumn{1}{|r}{0.182}&22&220,000\\
\midrule
\end{tabular}\end{mdtabular}

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{8}.}~\mdcaptiontext{Benchmark of Failure Case}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-failure}{8}%mdk
%mdk
\end{figure}%mdk

\noindent However, making a small modification to the program can make
open floating less effective. 
Consider a modified version of the \mdcode{square} function in Figure~\mdref{fig-bench}{\mdcaptionlabel{7}}.%mdk
\begin{mdpre}%mdk
{\def~{\nobreakspace{}}\begin{mdbpaddingx}{}{}{}{1em}%mdk
\noindent{\small noinline~{\mdcolor{navy}fun}~square'(~i~{\mdcolor{teal}:}~{\mdcolor{teal}int}~)~{\mdcolor{teal}:}~{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}exn}{\mdcolor{teal}\ensuremath{\rangle}}~{\mdcolor{teal}int}~~\\
~~{\mdcolor{navy}if}~{\mdcolor{purple}True}~{\mdcolor{navy}then}~i~*~i~{\mdcolor{navy}else}~throw({\mdcolor{maroon}"}{\mdcolor{maroon}impossible:~}{\mdcolor{maroon}"})}%mdk
\end{mdbpaddingx}}%mdk
\end{mdpre}\noindent We have removed \mdcode{++~ask\mdsub{1}(){\mdcolor{navy}.}show} and changed the effect from \mdcode{\ensuremath{\langle}ask\mdsub{1},~exn\ensuremath{\rangle}} to \mdcode{\ensuremath{\langle}exn\ensuremath{\rangle}}.
Just as before, the open floating reduces the number of $\mathpre{\mathkw{open}}$ calls in the \mdcode{test-one} function, but now the program runs slightly slower as shown in Figure~\mdref{fig-failure}{\mdcaptionlabel{8}}.

The reason why this happens is that the 
opened function (\mdcode{square'}) has an effect row type of length one.
In such case, the Koka runtime already optimizes the use of $\mathpre{\mathkw{open}}$
by avoiding allocating an explicit evidence vector and directly using
the single evidence \emph{as is}. Since no allocation happens, this can
be faster, in particular since the current implementation of the $\mathpre{\mathkw{restrict}}$ operation is not optimized in a similar fashion yet.
Instead, it is implemented combining a lambda abstraction and an $\mathpre{\mathkw{open}}$ operation, as
$\mathpre{\mathkw{restrict}~\mathid{e}~\doteq{}~\mathkw{open}(\lambda\_.~\mathid{e})()}$.
We plan to improve the implementation of $\mathpre{\mathkw{restrict}}$ in which case
it should always be beneficial to perform open floating.%mdk


\section{6.\hspace*{0.5em}Future Work}\mdlabel{sec-future}{6}%mdk%mdk

\noindent Even though our open floating algorithm is effective, there are 
still situations where it can be improved.
In particular, for certain higher-order programs, 
such as calls of map and fold, open floating can be improved.
Consider the following program.%mdk
\begin{mdpre}%mdk
{\def~{\nobreakspace{}}\begin{mdbpaddingx}{}{}{}{1em}%mdk
\noindent{\small{\mdcolor{navy}fun}~map(~xs~{\mdcolor{teal}:}~{\mdcolor{teal}list}{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}a}{\mdcolor{teal}\ensuremath{\rangle}},~f~{\mdcolor{teal}:}~{\mdcolor{teal}a}~{\mdcolor{teal}{\rmfamily\ensuremath{\rightarrow}}}~{\mdcolor{teal}e}~{\mdcolor{teal}b}~)~{\mdcolor{teal}:}~{\mdcolor{teal}e}~{\mdcolor{teal}list}{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}b}{\mdcolor{teal}\ensuremath{\rangle}}~\\
{\mdcolor{navy}fun}~g(~x~{\mdcolor{teal}:}~{\mdcolor{teal}int})~{\mdcolor{teal}:}~{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}ask}{\mdcolor{teal},}~{\mdcolor{teal}ndet}{\mdcolor{teal}\ensuremath{\rangle}}~{\mdcolor{teal}int}\\
\\
{\mdcolor{navy}fun}~f()~{\mdcolor{teal}:}~{\mdcolor{teal}\ensuremath{\langle}}{\mdcolor{teal}ask}{\mdcolor{teal},}~{\mdcolor{teal}exn}{\mdcolor{teal},}~{\mdcolor{teal}ndet}{\mdcolor{teal}\ensuremath{\rangle}}~{\mdcolor{teal}int}~~\\
~~...\\
~~map(lst,~g)\\
~~...}%mdk
\end{mdbpaddingx}}%mdk
\end{mdpre}\noindent The Koka compiler wraps the function $\mathpre{\mathid{g}}$ with an $\mathpre{\mathkw{open}}$ 
call to make the program type check.
This gives us the following expression.
\noindent\[\begin{mdmathpre}%mdk
\mathid{map}\,~\mathid{int}\,~\mathid{int}~\langle{}\mathid{ask},\mathid{exn},\mathid{ndet}\,\rangle{}~\mathid{lst}\,~(\mathkw{open}\langle{}\mathid{ask},~\mathid{exn},~\mathid{ndet}\,\rangle{}~\mathid{g})
\end{mdmathpre}%mdk
\]%mdk
\noindent The current open floating algorithm does not change the program due to the rule $\mathpre{\brulename{{Open-Preserve}}}$
as we discussed in Section~\mdref{sec-alg}{4.3}.
At runtime, the opened function is applied to each element in the list
\mdcode{lst} by the \mdcode{map} function.
It would be better to float the $\mathpre{\mathkw{open}}$ to surround the entire $\mathpre{\mathid{map}}$ call which reduces the number of $\mathpre{\mathkw{open}}$ calls to one like
$\mathpre{\mathkw{restrict}\langle{}\mathid{ask},~\mathid{ndet}\,\rangle{}(~\mathid{map}\,~\mathid{int}\,~\mathid{int}~\langle{}\mathid{ask},~\mathid{ndet}\,\rangle{}~\mathid{lst}\,~\mathid{g})}$.


\section{7.\hspace*{0.5em}Related Work}\mdlabel{sec-related}{7}%mdk%mdk

\noindent Our work is in the context of passing dynamic evidence vectors
at runtime that correspond to the static effect types, as described by~Xie and Leijen~[\mdcite{xie:gep}{20}].
The idea of passing dynamic runtime evidence for static properties is not
new and is a standard way of implementing qualified types and
type classes~[\mdcite{jones:qualifiedtypes}{5}, \mdcite{wadler:adhoc}{18}]. Here, the evidence takes
the form of a dictionary of overloaded operations and corresponds to the
qualified type constraints. In our work, $\mathpre{\mathkw{open}}$ adjusts the runtime evidence
vectors, while with type classes \emph{instances} are used to modify runtime
dictionaries. For example, a function with a \mdcode{\small Show~a} constraint may
call a function with a \mdcode{{\small Show~{}[a]}} constraint. To call this, the received dictionary
for \mdcode{\small Show~a} is transformed at runtime to a \mdcode{{\small Show~{}[a]}} dictionary
using the \mdcode{{\small instance~Show~a~=\textgreater{}~Show~{}[a]}} declaration. Usually,
these \textquotedblleft{}evidence adjustments\textquotedblright{} are called context reduction and generalized
by the entailment relation in the theory of qualified types~[\mdcite{jones:improvement}{6}].
Peyton Jones et al.~[\mdcite{peytonjones:exploration}{13}] explore the design space of sound context reduction in Haskell.%mdk

Gaster and Jones~[\mdcite{gasterjones:trex}{4}] present a system for extensible records based on
the theory of qualified types. Here, a \emph{lacks} constraint $\mathpre{\mathid{l}/\mathid{r}}$ corresponds
to a runtime evidence, providing the offset in the record $\mathpre{\mathid{r}}$ where
the label $\mathpre{\mathid{l}}$ would be inserted. When modifying the record, the evidence is also
adjusted at runtime to reflect a new offset. For example, if another label is
inserted before $\mathpre{\mathid{l}}$, its offset is incremented. A similar mechanism is used in
the system of type-indexed rows developed by~Shields and Meijer~[\mdcite{shields:xmlambda}{17}].%mdk


In all of the above examples, we can imagine transformations similar to
open floating that try to minimize the evidence adjustments, although we are
not aware of any previous work that addresses this issue specifically.%mdk

Our formalization of effect row can roughly be understood as
an instance of scoped rows discussed by~Morris and McKinna~[\mdcite{morris2019abstracting}{12}].
They define a general \emph{row theory} and \emph{row algebra} with qualified types.
Scoped rows are shown as an instance of them.
Closed prefix relation is almost represented as left containment relation.
Note that our calculus uses polymorphic effect rows such as $\mathpre{\forall \mu{}.\langle{}\mathid{l}_{1},~\mathid{l}_{2}\midbar{}\mu{}\,\rangle{}}$
while scoped rows in~[\mdcite{morris2019abstracting}{12}] do not seem to entail it.%mdk






\section{8.\hspace*{0.5em}Conclusion}\mdlabel{sec-conclude}{8}%mdk%mdk

\noindent In this paper, we formalized $\mathpre{\mathkw{open}}$ and $\mathpre{\mathkw{restrict}}$ with their restriction of the closed prefix relation.
The formalization clarifies the nature of the Koka language and the constraint of open floating.
We also defined the open floating algorithm on the formalized calculus and developed an implementation in Koka.
The benchmark shows the effectiveness of open floating and points out room to improve the implementation.%mdk

\subsubsection*{Acknowledgement}\mdlabel{sec-acknowledgement}{5}%mdk%mdk


\noindent We acknowledge the reviewers' efforts put into evaluation of our paper.
We also appreciate the FLOPS 2022 reviewers' feedback on an earlier version of the paper.
We also thank laboratory members.%mdk
%mdk-begin-texraw
This work was supported in part by JSPS KAKENHI under Grant No.~JP19K24339. 


\section*{Appendix}\mdlabel{app-wf}{8}%mdk%mdk


\noindent We present the well-formedness relation $\mathpre{\!\vdash_{\!\textsf{wf}}}$ and definitional equality of types $\mathpre{\!\vdash_{\!\textsf{eq}}}$ in Figure~\mdref{fig-wf}{\mdcaptionlabel{9}}.
The type rules (Figure~\mdref{fig-static}{\mdcaptionlabel{4}}) use these relations.%mdk

\begin{figure}[h]%mdk
\begin{mdflushleft}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\!\vdash_{\!\textsf{eq}}~\lambda \alpha{}^{\mathsf{k}_2}.\tau_{1}~{\equiv}~\tau_{1}'~\xcolon{}~\mathsf{k}_2{\rightarrow}\mathsf{k}~~~~~~\!\vdash_{\!\textsf{eq}}~\tau_{2}~{\equiv}~\tau_{2}'~\xcolon{}~\mathsf{k}_2}{\!\vdash_{\!\textsf{eq}}~\tau_{1}\,\tau_{2}~{\equiv}~{\tau}_\mathid{n}[\alpha{}^{\mathsf{k}_2}{:\!=}\tau_{2}']~\xcolon{}~\mathsf{k}}{\brulename{\textsc{KAPP}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\quad}{\!\vdash_{\!\textsf{eq}}~\alpha{}^{\mathsf{k}}~{\equiv}~\alpha{}^{\mathsf{k}}~\xcolon{}~\mathsf{k}}{\brulename{\textsc{KVAR}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\quad}{\!\vdash_{\!\textsf{eq}}~\mathid{c}^{\mathsf{k}}~{\equiv}~\mathid{c}^{\mathsf{k}}~\xcolon{}~\mathsf{k}}{\brulename{\textsc{KCONST}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\!\vdash_{\!\textsf{eq}}~\tau_{1}~{\equiv}~\tau_{1}'~\xcolon{}~\mathsf{k}_1}{\!\vdash_{\!\textsf{eq}}~\lambda \alpha{}^*.\tau_{1}~{\equiv}~\lambda \alpha{}^*.\tau_{1}'~\xcolon{}~*{\rightarrow}\mathsf{k}_1}{\brulename{\textsc{KABS}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\!\vdash_{\!\textsf{wf}}~{\tau}~\xcolon{}~*}{\!\vdash_{\!\textsf{eq}}~{\tau}~{\equiv}~{\tau}~\xcolon{}~*}{\brulename{\textsc{}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\!\vdash_{\!\textsf{eq}}~{\tau}~{\equiv}~{\tau}~\xcolon{}~*}{\!\vdash_{\!\textsf{wf}}~{\tau}~\xcolon{}~*}{\brulename{\textsc{}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\!\vdash_{\!\textsf{wf}}~\sigma_{1}\xcolon{}*~~~~\!\vdash_{\!\textsf{wf}}~\sigma_{2}\xcolon{}*~~~~\!\vdash_{\!\textsf{wf}}~{\epsilon}\xcolon{}\mathsf{eff}}{\!\vdash_{\!\textsf{wf}}~\sigma_{1}~{\rightarrow}~{\epsilon}~\sigma_{2}~\xcolon{}~*}{\brulename{\textsc{KFUN}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\!\vdash_{\!\textsf{wf}}~{\sigma}\xcolon{}*}{\!\vdash_{\!\textsf{wf}}~\forall \alpha{}^{\mathsf{k}}.{\sigma}~\xcolon{}~*}{\brulename{\textsc{KALL}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\begin{mdbmargintb}{1em}{1ex}%mdk
\begin{mdcenter}%mdk

\noindent$\mathpre{\infer{\!\vdash_{\!\textsf{wf}}~\mathid{l}~\xcolon{}~\mathsf{lab}~~~~\!\vdash_{\!\textsf{wf}}~{\epsilon}~\xcolon{}~\mathsf{eff}}{\!\vdash_{\!\textsf{wf}}~\langle{}\mathid{l}\midbar{}{\epsilon}\,\rangle{}~\xcolon{}~\mathsf{eff}}{\brulename{\textsc{KEFFECT}}}}$%mdk
%mdk
\end{mdcenter}%mdk
\end{mdbmargintb}%mdk

\mdhr{}%mdk

\noindent\mdcaption{\textbf{Figure~\mdcaptionlabel{9}.}~\mdcaptiontext{Well-formedness and Definitional Equality of Types of System $\mathpre{\mathsf{F}_{\mathid{pwo}}}$}}%mdk
%mdk
\end{mdflushleft}\mdlabel{fig-wf}{9}%mdk
%mdk
\end{figure}%mdk


\newpage{}%mdk

\mdsetrefname{References}%mdk
{\mdbibindent{0}%mdk
\begin{thebibliography}{20}%mdk
\mdlabel{sec-bibliography}{1}%mdk

%mdk-data-line={furudono2021.bib:139}
\bibitem{brachthauser2020effekt}\mdbibitemlabel{{}[1]}Jonathan Immanuel Brachth\"{a}user, Philipp Schuster, and Klaus Ostermann. \emph{Effekt: Lightweight Effect Polymorphism for Handlers}. Technical Report. University of T\"{u}bingen, Germany. 2020.\mdlabel{brachthauser2020effekt}{1}%mdk%mdk

%mdk-data-line={furudono2021.bib:147}
\bibitem{dolan2015effective}\mdbibitemlabel{{}[2]}Stephen Dolan, Leo White, KC Sivaramakrishnan, Jeremy Yallop, and Anil Madhavapeddy. \textquotedblleft{}Effective Concurrency through Algebraic Effects.\textquotedblright{} In \emph{OCaml Workshop}, 13. 2015.\mdlabel{dolan2015effective}{2}%mdk%mdk

%mdk-data-line={furudono2021.bib:1968}
\bibitem{felleisen:prompt}\mdbibitemlabel{{}[3]}Mattias Felleisen. \textquotedblleft{}The Theory and Practice of First-Class Prompts.\textquotedblright{} In \emph{Proceedings of the 15th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages}, 180–190. POPL ’88. Association for Computing Machinery, New York, NY, USA.~1988. doi:\href{https://dx.doi.org/10.1145/73560.73576}{10.1145/73560.73576}.\mdlabel{felleisen:prompt}{3}%mdk%mdk

%mdk-data-line={furudono2021.bib:1838}
\bibitem{gasterjones:trex}\mdbibitemlabel{{}[4]}Ben R.~Gaster, and Mark P.~Jones. \emph{A Polymorphic Type System for Extensible Records and Variants}. NOTTCS-TR-96-3. University of Nottingham. 1996.\mdlabel{gasterjones:trex}{4}%mdk%mdk

%mdk-data-line={furudono2021.bib:1761}
\bibitem{jones:qualifiedtypes}\mdbibitemlabel{{}[5]}Mark P.~Jones. \textquotedblleft{}A Theory of Qualified Types.\textquotedblright{} In \emph{4th. European Symposium on Programming (ESOP’92)}, 582:287–306. Lecture Notes in Computer Science. Springer-Verlag, Rennes, France. Feb. 1992. doi:\href{https://dx.doi.org/10.1007/3-540-55253-7_17}{10.1007/3-540-55253-7\_17}.\mdlabel{jones:qualifiedtypes}{5}%mdk%mdk

%mdk-data-line={furudono2021.bib:19}
\bibitem{jones:improvement}\mdbibitemlabel{{}[6]}Mark P.~Jones. \textquotedblleft{}Simplifying and Improving Qualified Types.\textquotedblright{} In \emph{Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture}, 160–169. FPCA ’95. La Jolla, California, USA.~1995. doi:\href{https://dx.doi.org/10.1145/224164.224198}{10.1145/224164.224198}.\mdlabel{jones:improvement}{6}%mdk%mdk

%mdk-data-line={furudono2021.bib:1516}
\bibitem{leijen:koka}\mdbibitemlabel{{}[7]}Daan Leijen. \textquotedblleft{}Koka: Programming with Row Polymorphic Effect Types.\textquotedblright{} In \emph{MSFP’14, 5th Workshop on Mathematically Structured Functional Programming}. 2014. doi:\href{https://dx.doi.org/10.4204/EPTCS.153.8}{10.4204/EPTCS.153.8}.\mdlabel{leijen:koka}{7}%mdk%mdk

%mdk-data-line={furudono2021.bib:757}
\bibitem{leijen:async}\mdbibitemlabel{{}[8]}Daan Leijen. \textquotedblleft{}Structured Asynchrony with Algebraic Effects.\textquotedblright{} In \emph{Proceedings of the 2nd ACM SIGPLAN International Workshop on Type-Driven Development}, 16–29. TyDe 2017. Oxford, UK.~2017. doi:\href{https://dx.doi.org/10.1145/3122975.3122977}{10.1145/3122975.3122977}.\mdlabel{leijen:async}{8}%mdk%mdk

%mdk-data-line={furudono2021.bib:132}
\bibitem{leijen2017type}\mdbibitemlabel{{}[9]}Daan Leijen. \textquotedblleft{}Type Directed Compilation of Row-Typed Algebraic Effects.\textquotedblright{} In \emph{Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages}, 486–499. 2017.\mdlabel{leijen2017type}{9}%mdk%mdk

%mdk-data-line={furudono2021.bib:835}
\bibitem{leijen:algeff}\mdbibitemlabel{{}[10]}Daan Leijen. \textquotedblleft{}Type Directed Compilation of Row-Typed Algebraic Effects.\textquotedblright{} In \emph{Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL’17)}, 486–499. Paris, France. Jan. 2017. doi:\href{https://dx.doi.org/10.1145/3009837.3009872}{10.1145/3009837.3009872}.\mdlabel{leijen:algeff}{10}%mdk%mdk

%mdk-data-line={furudono2021.bib:1025}
\bibitem{leijen:kokarepo}\mdbibitemlabel{{}[11]}Daan Leijen. \textquotedblleft{}Koka Repository.\textquotedblright{} 2019. \href{https://github.com/koka-lang/koka}{{\ttfamily https://\hspace{0pt}github.\hspace{0pt}com/\hspace{0pt}koka-\hspace{0pt}lang/\hspace{0pt}koka}}.\mdlabel{leijen:kokarepo}{11}%mdk%mdk

%mdk-data-line={furudono2021.bib:1}
\bibitem{morris2019abstracting}\mdbibitemlabel{{}[12]}J Garrett Morris, and James McKinna. \textquotedblleft{}Abstracting Extensible Data Types: Or, Rows by Any Other Name.\textquotedblright{} \emph{Proceedings of the ACM on Programming Languages} 3 (POPL). ACM New York, NY, USA: 1–28. 2019.\mdlabel{morris2019abstracting}{12}%mdk%mdk

%mdk-data-line={furudono2021.bib:12}
\bibitem{peytonjones:exploration}\mdbibitemlabel{{}[13]}Simon Peyton Jones, Mark Jones, and Erik Meijer. \textquotedblleft{}Type Classes: An Exploration of the Design Space.\textquotedblright{} In \emph{In Haskell Workshop}. 1997.\mdlabel{peytonjones:exploration}{13}%mdk%mdk

%mdk-data-line={furudono2021.bib:1335}
\bibitem{plotkin:handlers}\mdbibitemlabel{{}[14]}Gordon D.~Plotkin, and Matija Pretnar. \textquotedblleft{}Handling Algebraic Effects.\textquotedblright{} In \emph{Logical Methods in Computer Science}, volume 9. 4. 2013. doi:\href{https://dx.doi.org/10.2168/LMCS-9\%25284:23\%25292013}{10.2168/LMCS-9(4:23)2013}.\mdlabel{plotkin:handlers}{14}%mdk%mdk

%mdk-data-line={furudono2021.bib:372}
\bibitem{pretnar:efficientcomp}\mdbibitemlabel{{}[15]}Matija Pretnar, Amr Hany Shehata Saleh, Axel Faes, and Tom Schrijvers. \emph{Efficient Compilation of Algebraic Effects and Handlers}. CW Reports. Department of Computer Science, KU Leuven; Leuven, Belgium. 2017. \href{https://lirias.kuleuven.be/retrieve/472230}{{\ttfamily https://\hspace{0pt}lirias.\hspace{0pt}kuleuven.\hspace{0pt}be/\hspace{0pt}retrieve/\hspace{0pt}472230}}.\mdlabel{pretnar:efficientcomp}{15}%mdk%mdk

%mdk-data-line={furudono2021.bib:365}
\bibitem{schrijvers:effsub}\mdbibitemlabel{{}[16]}Amr Hany Shehata Saleh, Georgios Karachalias, Matija Pretnar, and Tom Schrijvers. \textquotedblleft{}Explicit Effect Subtyping.\textquotedblright{} In \emph{27th European Symposium on Programming (ESOP)}. 2018.\mdlabel{schrijvers:effsub}{16}%mdk%mdk

%mdk-data-line={furudono2021.bib:32}
\bibitem{shields:xmlambda}\mdbibitemlabel{{}[17]}Mark Shields, and Erik Meijer. \textquotedblleft{}Type-Indexed Rows.\textquotedblright{} In \emph{Proceedings of the 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages}, 261–275. POPL’01. London, United Kingdom. 2001. doi:\href{https://dx.doi.org/10.1145/360204.360230}{10.1145/360204.360230}.\mdlabel{shields:xmlambda}{17}%mdk%mdk

%mdk-data-line={furudono2021.bib:1747}
\bibitem{wadler:adhoc}\mdbibitemlabel{{}[18]}Philip Wadler, and Stephen Blott. \textquotedblleft{}How to Make Ad-Hoc Polymorphism Less Ad Hoc.\textquotedblright{} In \emph{Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages}, 60–76. POPL ’89. ACM, Austin, Texas, USA.~1989. doi:\href{https://dx.doi.org/10.1145/75277.75283}{10.1145/75277.75283}.\mdlabel{wadler:adhoc}{18}%mdk%mdk

%mdk-data-line={furudono2021.bib:122}
\bibitem{xie2020effect}\mdbibitemlabel{{}[19]}Ningning Xie, Jonathan Immanuel Brachth\"{a}user, Daniel Hillerstr\"{o}m, Philipp Schuster, and Daan Leijen. \textquotedblleft{}Effect Handlers, Evidently.\textquotedblright{} \emph{Proceedings of the ACM on Programming Languages} 4 (ICFP). ACM New York, NY, USA: 1–29. 2020.\mdlabel{xie2020effect}{19}%mdk%mdk

%mdk-data-line={furudono2021.bib:1930}
\bibitem{xie:gep}\mdbibitemlabel{{}[20]}Ningning Xie, and Daan Leijen. \textquotedblleft{}Generalized Evidence Passing for Effect Handlers: Efficient Compilation of Effect Handlers to C.\textquotedblright{} \emph{Proc. ACM Program. Lang.} 5 (ICFP). Association for Computing Machinery, New York, NY, USA.~Aug. 2021. doi:\href{https://dx.doi.org/10.1145/3473576}{10.1145/3473576}.\mdlabel{xie:gep}{20}%mdk%mdk
\par%mdk
\end{thebibliography}}%mdk%mdk%mdk


\end{document}
